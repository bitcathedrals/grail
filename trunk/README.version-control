Version Control Notes:

The Master Repository is a subversion repository.  It is used for
storing all of the releases, large and small.

All of the commits to the Master Repository should be bisect atomic in
that they are a complete feature/bug changeset that moves the tree
from one well defined state to the next.

The Development Repository is Baazar (bzr).

Baazar was chosen because it appears to place flexibility as it's
highest value, and flexibility is priceless to me.

I still use SubVersion as a master tree because it is extremely robust
and mature, it is the safe deposit box so to speak. The simplicity of
the centralized repository model also darastically reduces the
opportunity for confusion to spread chaos in sycnhronization.

As far as development features bzr seems to be far and away the best
in terms of features. The plethora of branching, stacking, and plugin
features gives me a warm fuzzy feeling that I won't be hacking odd
wrappers to contort bzr into a workflow I want.

bzr is also portable to the systems I use: linux,darwin, and possibly
windows down the road.

My Workflow:

The Master repository contains a trunk, the development version ideally
kept in a working state, and releases.

project/trunk
project/0.1.3

When a release is ready it is branched, and the merge info is recorded
so subversion doesn't get jammed up with lacking merge info.

In a development repository the goal is to produce atomic changesets.
There for it would look like this:

Master Trunk   -> /mattie
               -> /feature.x
               -> /feature.y
               -> /bugfix.a
               -> /bugfix.b


This sort of layout allows more than one user to hack away,
and to pool efforts in creating the atomic changesets.

Committing back to the main repository involves a hyrbid checkout
and merging the individual branches.

At each proper release from the master the old bazaar can be
dumped, with any leftovers going into some master repository
branch like "attic".

A shared repository is neccessary because a synchronizing checkout
must be made, and testing needs to go on in a seperate directory
mixing and matching the various atomic changesets.

It would also be desireable to be able to quickly make a backport
checkout as well to merge fixes applicable to previous releases.


Procedure:

1. create a bzr shared repository:

bzr init-repo [foo]

giving [foo] as an arg seems to be the magic dust to get a shared repo

populate the shared repository with:
cd [foo]
bzr init --create-prefixes emacs/trunk

bridge it to svn:
svn co $TOOLKIT/system/emacs/trunk emacs/trunk

it is now bridged, or the state is shared between both bzr
and subversion.

1. create a sandbox.

create a sandbox with bzr init

inside the sandox do a bzr checkout ~/local/vc/bzr/emacs/trunk trunk


1. create a user branch

now *in the shared repository* create the user branch.

bzr branch ~/local/vc/bzr/emacs/{trunk,mattie}

then check it out

bzr checkout ~/local/vc/bzr/emacs/mattie mattie

the trunk becomes the merge queue. To make it work this way unbind
it.

cd trunk && bzr unbind

now all the commits are local until it is rebound. This is much safer
as far as the merge queue goes.

* user devel branch

create the branch *in the shared repo*

bzr branch REPO/{trunk,mattie}

Then check it out
bzr checkout REPO/mattie

everything in the sandbox is rooted to the trunk, the changesets, and
"mattie" as the development head.

the individual changesets are created as branches of the trunk. The changes
accumulate in the changesets until they are cooked.

When it is time to uncork the queue rebind the trunk:

cd trunk && bzr bind

synchronize it with the shared repo:

bzr update

send the queue to the shared repo:

bzr commit

NOTE:

only the trunk should be unbound ! the work in progress on mattie, changeset.x
and bugfix. should be left bound ! otherwise the work is not portable between
machines. It is a sandbox not a private copy.
