
---> Grok List <---

* look at replace-regex being able to call lisp code. that is insanely
  great.

* saw some fella using union to merge alists in his emacs. Evidently it's
  in the cl package. Very interesting. I should look at doing this in my
  config to avoid dups.

* explore vc group commits which may be very similar to what I want
  with my merge mode.

---> BUGS <---

* highlighting sexp is still not working on linux. why ? it works
  on emacs.app 0.9.x

* simple-set-theme doesn't clear properties before setting. a good example
  is the flyspell underline. because it is merging instead of replacing it
  is displaying in the orange specified by flyspell.

* tool-bar-mode nil has no effect on Emacs.app

* flypsell in comments only seems to analyze the text after I pass over the
  word with the cursor. This is probably a configuration issue.

---> TODO <---

* examine-library has a terrible prompt and no completion.
  Fix the prompting and completion so it can exit alpha.

* use def-advice to set the mark when insert-key-notation is
  used so that it can easily be copied as a region.

* setq-default is far more apropo than the vanilla setq used throughout
  most of emacs.el currently. review the use of setq in emacs.el and
  convert to setq-default as appropriate.

* There should be two arguements to tune-programming, a language, and
  a keybinding. The keybinding if nil should be derived from the value
  of language. This way the language can be set independent of some
  uber-dwim completion scheme.

* localize-distrib works in a crude way, in that it creates the right
  file, but it does not keep track of version information. At the least
  it should store in a buffer local variable so that diffing can be
  performed and the ancestor information can be inserted into the diff
  header.

  where the fuck is the standard for diff ?

---> Planned <---

* load guard could be extended into something pretty interesting. If it used dl-elisp
  it could compile a defun that would download necessary files, and re-execute the
  failed configuration.

  where it would get complex is choosing the best available method. paludis ? macports ?
  url fetch with dl-elisp ?

  currently the idea is simmering as a defun in spell.el. I tried the install-flyspell
  command and it worked pretty well.

  simply placing the generation of install options before the require to kill eval
  if it cannot load works pretty well.

  If this gets developed further it will eventually turn into a wrapper around
  a broad spectrum of package managers, much like how vc provides a common
  interface for a range of vcs systems. This is a medium sized project that
  needs to go on the back-burner.

* Spelling

  PredictiveMode http://www.emacswiki.org/cgi-bin/wiki/PredictiveMode

  This mode is what I will want inside of comments eventually, and for text jobs.

* Documentation.

  high priority.

  tame the info browser. I need it to not always full-screen, and to be able
  to narrow the searches by criteria, say restrict a java function to the 1.4
  spec etc.

  I need to use google less as a documentation system. It is not as efficient
  as using some info based facility in emacs, and it does not work when I am
  offline.

  Java reference

  susv3

  various darwin API's

  elisp manual

  common lisp hyperspec

  unique feature:

  for a given API create a screen that combines various versions into a single
  document. This way you can see the "standard" and various implementations/versions

  when reading on a particular API.

  apple is using docbook for darwin. Definitely will need a toolchain that targets
  texinfo ?

  what is the ideal documentation browser in emacs ?

  what about using the w3 browser ?

  What I am thinking at the moment is a package manager tree that installs documents
  as Texinfo.

  awesome ! kawa docs are supplied in info format. truly awesome.

  I can definitely use the docbook approach when the upstream is in docbook. What
  I am looking at now is how to integrate into the package manager.

  I need to support multiple package managers. I probably need to do something
  like create a makefile for each one. Basically download and unpack the docbook
  source, Then have my makefile do the conversion to Texinfo.

  how that conversion gets specified is interesting. I know little about either format.
  This is going to be a major stumbling block, more so than tangling with the various
  package managers.

  need to create a way to compute the position of the document tree in a "catalog"
  that allows efficient navigation. This is definitely a library science domain
  that I need to shortcut across quickly.

  Need to specify the conversion, probably very specific to a source document ?

* Icicles uber-dwim

  map the cycle keys to something that works decently on the happy hacker keyboard.
  also look into the more advanced matching techniques and map those so I can use
  them.

  look at turning contextualized-tab into a flexible coupling with icicles. the
  key ability of something like contextualized-tab would be the ability to
  add multiple domains/completion functions in a way that is intelligable to
  icicles. Then integrating icicles would be easy. contextualized-tab would
  be responsible for establishing the domain first.

* Slime/Sepia

.. Sepia

   need to attempt install after the gentoo local repository is moved.

.. Slime

  enable slime mode

* JVM ?

  have it send function definitions to the via interpreter comint-invisible
  or other methods ala slime

---> JUNK <--- misc notes from the old TODO file.

* General

.. check out paren-edit. I don't know what the feature list is, but
   it is rumored to be quite handy.

.. the C-xe binding should be a general execute emacs code concept.
   in interactive mode it should replace C-u-x-e as a much shorter
   binding. In any other sort of buffer it should run eval-expression.

   how could this be taken advantage of in non-elisp buffers ?

* code navigation

  navigate by terms,tokens (for imperative languages)

  Move forwards and backwards in syntax by terms. This is only needed in
  imperative languages.

* Better template modes

.. Basic integration

   mode loading is now done except for the completely hosed install system.
   there needs to be an autoconf to deal with compiling emacs code. There
   are way to many varations. generate makefiles with various emacs quirks.

* Merging

** Co-process interpreters

* Debugger

.. gud does not have a common hook. It should for things like fixing
   the keybindings for input history. Make the appropriate hook.

* Just for Fun

  build a foreign function interface that allows parrot closures
  to be created and called from emacs by embedding parrot ( insane+ ).

  allow parrot code to callback into emacs, analyze risk of
  changing semantics,side-effects etc.

  push up syntax trees into the invisible annotations of a buffer.
  be able to sync via a function.

  is it the mythical Babel :) they will run screaming.

* glasses-mode can be used for langauges that use case-change
  as a word seperator e.g: FooBar

  A. the main part is done. I need to copy the original as well for
     diffing against.  It also needs to have version information
     encoded !!!!! I should be able to get the strings of the current
     emacs version, and then encode that. How to ensure that further
     diffs work ? possibly emit a script to perform the diff.

* use comint 'send-invisible' to dump a function into the interperter,
  for this to be really cool , it would need to copy the function by tags lookup
  automatically reformatting as necessary.

* env-tree needs to be modified to work with the env program. Simply
  executing a subshell will not work with things like eshell which I
  use on emacs, other systems like windows where the shell is not fully
  intergrated will rely on a program like env as well.

* vc stuff

  -> vc-before-checkin-hook is run right before the pop-to-buffer
     command in vc-start-entry. As long as there are no side effects
     changing the current-buffer to a read-only diff between the
     working-copy and the current version should work. No cleanup
     would be performed though :( TODO

     -> needs to get the file value for the current buffer: the working copy.

     -> diff against last checkin

     -> make the diff read-only

     -> make the current buffer the diff.

* Things needed:

   hunk recovery. The ability to scrub all the plus and minuses to
   restore the text encompassed by a hunk to it's original content.

* ediff mode has a two way toggle between the merge buffer and a
  custom diff with the 'D' key. The toggle currently displays the
  custom diff in the ediff control panel window which is a single line
  by default (iconified).

  * make the custom diff appear in the merge window.

  * make the custom diff a made ediff-merge 'D' first a two toggle of
    the custom diff and the merge buffer in AB merged window

* three way 'D' toggle adding the final merged file for committing
  partial merges it needs to update all the windows and the
  emerge-changes variables as necessary.
