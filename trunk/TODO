
* look at replace-regex being able to call lisp code. that is insanely
  great.

;; use def-advice to set the mark when insert-key-notation is
;; used so that it can easily be copied as a region.

;; stateful implementation of map-filter-nil.

;; stateful version by fledermous in #emacs (thanks)
;; (remove nil (mapcar fun (remove nil list)))

;; stateful version by sabetts in #emacs (thanks).
;;(defun map-reduce (fn &rest list)
;;  (let (acc v)
;;    (while list
;;      (setq v (pop list)
;;            v (and v (funcall v)))
;;      (when v (push v acc)))
;;    acc))

* Bugs

 hihglighting sexp is still not working on linux. why ? it works
 on emacs.app 0.9.x

  simple-set-theme doesn't clear properties before setting. a good example
  is the flyspell underline. because it is merging instead of replacing it
  is displaying in the orange specified by flyspell.

* badly need flyspell on comments.

* load gaurd could be extended into something pretty interesting. If it used dl-elisp
  it could compile a defun that would download necessary files, and re-execute the
  failed configuration.

  where it would get complex is choosing the best available method. paludis ? macports ?
  url fetch with dl-elisp ?

  currently the idea is simmering as a defun in spell.el. I tried the install-flyspell
  command and it worked pretty well.

  simply placing the generation of install options before the require to kill eval
  if it cannot load works pretty well.

* Documentation.

  I need to use google less as a documentation system. It is not as efficient
  as using some info based facility in emacs, and it does not work when I am
  offline.

  Java reference

  susv3

  various darwin API's

  elisp manual

  common lisp hyperspec

  unique feature:

  for a given API create a screen that combines various versions into a single
  document. This way you can see the "standard" and various implementations/versions

  when reading on a particular API.

  apple is using docbook for darwin. Definitely will need a toolchain that targets
  texinfo ?

  what is the ideal documentation browser in emacs ?

  what about using the w3 browser ?

  What I am thinking at the moment is a package manager tree that installs documents
  as texinfo.

  awesome ! kawa docs are supplied in info format. truly awesome.

  PredictiveMode http://www.emacswiki.org/cgi-bin/wiki/PredictiveMode

  This mode is what I will want inside of comments eventually, and for text jobs.

* General

.. saw some fella using union to merge alists in his emacs. Evidently it's
   in the cl package. Very interesting. I should look at doing this in my
   config to avoid dups.

.. setq-default is far more apropo than the vanilla setq used throughout
   most of emacs.el currently. review the use of setq in emacs.el and
   convert to setq-default as appropriate.

.. explore vc group commits which may be very similar to what I want
   with my merge mode.

.. the C-xe binding should be a general execute emacs code concept.
   in interactive mode it should replace C-u-x-e as a much shorter
   binding. In any other sort of buffer it should run eval-expression.

   how could this be taken advantage of in non-elisp buffers ?

   .. Options

   (done) hook it into else for epanding templates

   have it send function defintions to the interpeter via comint-invisible
   or other methods ala slime

.. general cleanup of bindings in the source file, so that it is somewhat
   apparent how things are bound without C-h-b.

  1. There should be two arguements to tune-programming, a language, and
     a keybinding. The keybinding if nil should be derived from the value
     of language. This way the language can be set independent of some
     uber-dwim completion scheme.

.. examine-library has a terrible prompt and no completion.

.. I should have a command that allows me to look through any lisp file
   in read-only mode. When I turn it writable it needs to copy the file
   to my local dir and do a write-file to switch the buffer.

   .. this should encode version information in the diff, so you know
      the common ancestor.

* input completion

  .. ultimate template refactor system

* code navigation

.. navigate by terms,tokens (for imperative languages)

Move forwards and backwards in syntax by terms. This is only needed in
imperative languages.

* Better template modes

.. Basic integration

   mode loading is now done except for the completely hosed install system.
   there needs to be an autoconf to deal with compiling emacs code. There
   are way to many varations. generate makefiles with various emacs quirks.

* Merging

** Co-process interpreters

.. Sepia

   need to attempt install after the gentoo local repository is moved.

.. Slime

  enable slime mode

* Debugger

.. gud does not have a common hook. It should for things like fixing
   the keybindings for input history. Make the appropriate hook.

* Pure Evil

  build a foreign function interface that allows parrot closures
  to be created and called from emacs by embedding parrot ( insane+ ).

  allow parrot code to callback into emacs, analyze risk of
  changing semantics,side-effects etc.

  push up syntax trees into the invisible annotations of a buffer.
  be able to sync via a function.

  code name: Babel :) they will run screaming.

* glasses-mode can be used for langauges that use case-change
  as a word seperator e.g: FooBar

  A. the main part is done. I need to copy the original as well for
     diffing against.  It also needs to have version information
     encoded !!!!! I should be able to get the strings of the current
     emacs version, and then encode that. How to ensure that further
     diffs work ? possibly emit a script to perform the diff.

* use comint 'send-invisible' to dump a function into the interperter,
  for this to be really cool , it would need to copy the function by tags lookup
  automatically reformatting as necessary.

* env-tree needs to be modified to work with the env program. Simply
  executing a subshell will not work with things like eshell which I
  use on emacs, other systems like windows where the shell is not fully
  intergrated will rely on a program like env as well.

* vc stuff

  -> vc-before-checkin-hook is run right before the pop-to-buffer
     command in vc-start-entry. As long as there are no side effects
     changing the current-buffer to a read-only diff between the
     working-copy and the current version should work. No cleanup
     would be performed though :( TODO

     -> needs to get the file value for the current buffer: the working copy.

     -> diff against last checkin

     -> make the diff read-only

     -> make the current buffer the diff.

* Things needed:

   hunk recovery. The ability to scrub all the plus and minuses to
   restore the text encompassed by a hunk to it's original content.

* ediff mode has a two way toggle between the merge buffer and a
  custom diff with the 'D' key. The toggle currently displays the
  custom diff in the ediff control panel window which is a single line
  by default (iconified).

  * make the custom diff appear in the merge window.

  * make the custom diff a made ediff-merge 'D' first a two toggle of
    the custom diff and the merge buffer in AB merged window

* three way 'D' toggle adding the final merged file for committing
  partial merges it needs to update all the windows and the
  emerge-changes variables as necessary.
