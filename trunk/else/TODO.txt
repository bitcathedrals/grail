* BUG

  my insert command is definitely causing a severe bug. it comes from
  else-before-change . I think it has to due with the size of the change
  being zero.


  found symbol's function definition is void

  yep, it thinks it is in a placeholder. it is not.

  648 this is where the error is triggering.

  else-in-placeholder looks insane. It is a totally hand hacked depth/regex combo
  of doom.

  questions:
    why are the hooks even running ? when we are done with the template we should kill
    the hooks. no more bugs.

    this kills comment out or any other chronology based revisit template for later,
    or does it ?


  signalling that a template editing session is complete is essential. It simply is *not*
  going to fly otherwise.

  these change hooks are probably why I am having serious problems with movement, especially
  when keys are held down.


  Need to look at bounding, such as narrowing on expand. Need some firewalls that will
  contain computations gone bad.

  Need to indicate active expansion and bounding. If Narrowing isn't visual, then it
  is time to enable a template expansion highlight.

  a fix is in place. It may not be entirely correct but it is holding.

* compare with alternatives

  MsfAbbrev

  smart-snippet

  AutoInsertMode

  SkeletonMode

  RecipeForSkeletonMode

* Basic Integration

  Ponder over the schema that I am creating for languages. I haven't
  put much thought in so it is probably pretty cruddy.

  create an autoconf file for dealing with host configuration and
  emacs version issues. The compilation problem with .esl files has
  brought this to light. This is a more general problem with the
  entire config, just keep the else part in the loop when it gets
  fixed.

*  macro assembler.

  A Macro Assembler that compensates for the stateless design of else
  template definition interpretation. The definition language has
  limitations that are easily overcome with an intermediate form that
  allows the relationship between various declarations to be
  computeted by the assembler, such as autosub counts. Using a tree
  structure also allows for scoping which allows common names to be
  re-used.

.. implement optional

.. implement menu ? ( big one )

  . schema

  need a schema that I can use to validate the documents. Is it
  even possible to validate with any schema due to the ability
  to create arbitrary tag names ? if not then the checking
  will have to be placed in assembler.

  .. elisp generator

  when the elisp backend is created it should generate auto-loads for
  all of the templates reducing loading? and memory use.

* Short Term

. Usability

  .. errors

  error handling needs to be sorted out. If there are serious loading errors
  in non-interactive parts of else-xml then it needs to go to messages. If
  it is coming from a interactive function it needs to go on the modeline.

  How do I get the errors from the else define interpreter ? or from assemble
  for that matter ?

  .. create new

  the compile a buffer command is still not tested.

  merge is yet to be implemented.

  the insertion point needs to be specified as an xpath expression.
  this way the macros can be inserted into multi-namespace documents
  where the document root is something other than else. The default
  should be append to else though.

  something like XSH2 would be pretty slick here. In fact this is
  definitely XSH2 worthy. Damn.

  .. complete

  Tab complete token/placeholder symbols. This would be a nice
  feature, and it would be a good way to get into the completion
  API's.

  need to be able to create a macro in a buffer and load it.

  .. documentation

  continue documenting one component at a time. The next component
  is Builder::.

  .. implementation


* Medium Term

  .. pre-loader

  split else-load-xml into else-load-xml-{global,local}

  Instead of doing a global/local hack it should be designed generally.
  When loading, files should be loaded into a set, which is basically
  a division of the search space. There should then be a default
  set, and a way to set buffer local a set. The search routines
  would then use a simple API to a more flexible system.

  The default should be a emulation of the existing global/local or
  as it is called overlay.

  to keep it truly as simple as possible it may be interesting to
  simply place the entire search space in a single hash table
  and generate the sets in assemble. Otherwise a hash table per
  set will likely be necessary. Auto-load tricks may be exploitable
  to "relink" on load. Doing it as each set is a hash is more
  like relocatable.

  It may be possible to make sets multi-language. It should be an option.
  It should also be an option to make a set that is specific to a language :)

  .. indent

  indent value should not be taken from the template file. It should
  be supplied as an arguement to the tune-else and do whatever is
  neccessary to recompile the templates. Deferred compilation of the
  templates should be considered.

  implement generation of multiple languages at a time ? ( ponder dropping this
  feature since I can just run the assembler repeatedly.

  settings the mark at the beginning of the template expansion would be nice
  so that the template can be easily copied. advise looks like a way
  to do this cleanly.

* Major contributions

  .. Toolbox ideas

  Add in some of the old toolbox ideas. Each token should be a
  repository of general programming knowledge. The purpose of
  the templates is to be able to rapidly instantiate that
  knowledge into a particular technique.

  The Compound nature of XML is a good fit for assembling data
  like this.

  implemented description tag which turns the body into extended
  documentation that is stripped. Along with leveraging the
  namespaceURI for language specifics the design is layed out.

  .. Chunks

  Generate "chunks" in template expansion which are incomplete code
  fragments that are loaded into registers or some such temporary
  facility. That way you can use those chunks after the template in
  writing new code.

  .. refactor with parameters

  The ability to mark a region of code and pass it as the value for a
  terminal placeholder. This allows code to be re-factored quickly.

  the ability to supply the parameters to the template function. this
  may involve the creation of a sort of special expand form , where it
  would look like a elisp function, however it would start the
  template expansion with the replacements given as arguments.

  (macro foo bar baz)

  expand it, and have foo bar and baz supplied as the replacement text
  for the subs.

* Long Term

  have the macro assembler generate elisp code instead of the
  definition language, and compile the results directly.

  .. The loader idea

  It is a fundamental assumption throughout else-mode that loading a
  file loads all of the necessary templates. I would much rather load
  them as needed in sets. A loader could be constructed that would
  implement dependencies so that any set can be easily loaded.

  The loader would have to communicate via IPC with emacs to do this.
  It would need to be able to see if a given set is already loaded
  and that can only be done inside emacs.

* Macro ideas

  .. Perl5

  a macro for method creation
  a macro for method invocation
