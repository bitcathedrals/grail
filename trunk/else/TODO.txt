* Basic Integration

  Ponder over the schema that I am creating for languages. I haven't
  put much thought in so it is probably pretty cruddy.

  create an autoconf file for dealing with host configuration and
  emacs version issues. The compilation problem with .esl files has
  brought this to light. This is a more general problem with the
  entire config, just keep the else part in the loop when it gets
  fixed.

  Put in some sort of test framework. It should be fairly easy to
  check against the reference output.

  .. macro translater -> macro assembler.

  A Macro Assembler that compensates for the stateless design of else
  template definition interpretation. The definition language has
  limitations that are easily overcome with an intermediate form that
  allows the relationship between various declarations to be
  computeted by the assembler, such as autosub counts. Using a tree
  structure also allows for scoping which allows common names to be
  re-used.

* Short Term

  indent value should not be taken from the template file. It should
  be supplied as an arguement to the tune-else and do whatever is
  neccessary to recompile the templates. Deferred compilation of the
  templates should be considered.

  Tab complete token/placeholder symbols. This would be a nice
  feature, and it would be a good way to get into the completion
  API's.

* Medium Term

* Major contributions

  .. Toolbox ideas

  Add in some of the old toolbox ideas. Each token should be a
  repository of general programming knowledge. The purpose of
  the templates is to be able to rapidly instantiate that
  knowledge into a particular technique.

  The Compound nature of XML is a good fit for assembling data
  like this.

  implemented description tag which turns the body into extended
  documentation that is stripped. Along with leveraging the
  namespaceURI for language specifics the design is layed out.

  .. Chunks

  Generate "chunks" in template expansion which are incomplete code
  fragments that are loaded into registers or some such temporary
  facility. That way you can use those chunks after the template in
  writing new code.

  .. refactor with parameters

  The ability to mark a region of code and pass it as the value for a
  terminal placeholder. This allows code to be re-factored quickly.

  the ability to supply the parameters to the template function. this
  may involve the creation of a sort of special expand form , where it
  would look like a elisp function, however it would start the
  template expansion with the replacements given as arguments.

  (macro foo bar baz)

  expand it, and have foo bar and baz supplied as the replacement text
  for the subs.

* Long Term

  have the macro assembler generate elisp code instead of the
  definition language, and compile the results directly.

  .. The loader idea

  It is a fundamental assumption throughout else-mode that loading a
  file loads all of the necessary templates. I would much rather load
  them as needed in sets. A loader could be constructed that would
  implement dependencies so that any set can be easily loaded.

  The loader would have to communicate via IPC with emacs to do this.
  It would need to be able to see if a given set is already loaded
  and that can only be done inside emacs.

* Macro ideas

  .. Perl5

  a macro for method creation
  a macro for method invocation
