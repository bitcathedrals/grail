* Design

.. What is the value of a template system ?

. , Template systems save keystrokes

    how many keystrokes are saved with the overhead of keymaps ?

    can a large set of templates be used without having to type
    really long names ?


. , template systems promote bad code



* else mode needs to be able to use easier commands than the usual expansions.
  It should be able to do this with the core functionality behind hyperlinks.
  In the region of a placeholder that has not been expanded yet.

* Paper



  can templates lower the number of defects entered ?

  can templates help "recall" a language you haven't used for a while ?

.* compare with alternatives

.. MsfAbbrev

.. smart-snippet

.. AutoInsertMode

.. SkeletonMode

.. RecipeForSkeletonMode

.* create a video of else in action

  have a first draft video now.

*  macro assembler.

  A Macro Assembler that compensates for the stateless design of else
  template definition interpretation. The definition language has
  limitations that are easily overcome with an intermediate form that
  allows the relationship between various declarations to be
  computeted by the assembler, such as autosub counts. Using a tree
  structure also allows for scoping which allows common names to be
  re-used.

.. implement non-local placeholder references

   going to have to make a major change here. Currently only local
   placeholders can be used. This will not work long term.

   add a g="" that is "global". This needs to use the token expansion
   which is lower cased and dashed.

   can global placeholders be "contextualized ?", this is an interesting
   question. say you want to repeat, can you wrap a existing placeholder
   with new options in a sensible way ?

.. implement optional

.. implement menu ? ( big one )

.. implement prefix

  This should be alot easier to add now as another rewrite during
  traverse.

  .. elisp generator

  when the elisp backend is created it should generate auto-loads for
  all of the templates reducing loading? and memory use.

.* cleanups

.. use carp

   convert all of the die statements to carp statements, so that a backtrace is
   supplied on such severe errors.

.. TODO items

   systematically review the BROWN BAG and TODO markers in the code.

* packaging/integration.

  Ponder over the schema that I am creating for languages. I haven't
  put much thought in so it is probably pretty cruddy.

  create an autoconf file for dealing with host configuration and
  emacs version issues. The compilation problem with .esl files has
  brought this to light. This is a more general problem with the
  entire config, just keep the else part in the loop when it gets
  fixed.

  Think about a gentoo ebuild once the files are sanitized as clean
  emacs libraries.

  . schema

  need a schema that I can use to validate the documents. Is it
  even possible to validate with any schema due to the ability
  to create arbitrary tag names ? if not then the checking
  will have to be placed in assembler.


* going beyond repeating, and injecting syntatic sugar between
  typed text, what good is a templating system as far as code
  generation goes ?

  for example:

  my ( $foo , $bar ) = splice @_,0,2

  in this case a good templating system would count the number
  of list entries and adjust the length of the splice accordingly.

  how could else-mode deal with something like this ? is it even
  possible with the current design ?

  how about translaters ? things like making regex in lisp doable
  by translating something decent like pcre into lisp ? sed ? etc ?
  that way you only have to learn one syntax for basic expressions.

  this can be done with the emacs hooks I think. The important part
  would be state for a placeholder. Maybe this could be done by
  attaching the state to text properties. can you put a variable
  in properties ?

  simple signals and receivers, make it easy to generate various
  signals without alot of elisp, simple elisp way to recieve the
  signals and update state. expand on signal ?

* Short Term

. Usability

  .. errors

  error handling needs to be sorted out. If there are serious loading errors
  in non-interactive parts of else-xml then it needs to go to messages. If
  it is coming from a interactive function it needs to go on the modeline.

  How do I get the errors from the else define interpreter ? or from assemble
  for that matter ?

  .. create new

  merge is yet to be implemented.

  the insertion point needs to be specified as an xpath expression.
  this way the macros can be inserted into multi-namespace documents
  where the document root is something other than else. The default
  should be append to else though.

  something like XSH2 would be pretty slick here. In fact this is
  definitely XSH2 worthy. Damn.

  do a really simple merge for starters that appends at the document
  root. The whole xpath thing is for generalized insert into abitrary
  XML which is 1.0 , but we are still in alpha. keep it simple to
  keep progressing.

  .. complete

  Tab complete token/placeholder symbols. This would be a nice
  feature, and it would be a good way to get into the completion
  API's.

  need to be able to create a macro in a buffer and load it.

  .. documentation

  continue documenting one component at a time. The next component
  is Builder::.

  .. implementation


* Medium Term

  .. pre-loader

  split else-load-xml into else-load-xml-{global,local}

  Instead of doing a global/local hack it should be designed generally.
  When loading, files should be loaded into a set, which is basically
  a division of the search space. There should then be a default
  set, and a way to set buffer local a set. The search routines
  would then use a simple API to a more flexible system.

  The default should be a emulation of the existing global/local or
  as it is called overlay.

  to keep it truly as simple as possible it may be interesting to
  simply place the entire search space in a single hash table
  and generate the sets in assemble. Otherwise a hash table per
  set will likely be necessary. Auto-load tricks may be exploitable
  to "relink" on load. Doing it as each set is a hash is more
  like relocatable.

  It may be possible to make sets multi-language. It should be an option.
  It should also be an option to make a set that is specific to a language :)

  .. indent

  indent value should not be taken from the template file. It should
  be supplied as an arguement to the tune-else and do whatever is
  neccessary to recompile the templates. Deferred compilation of the
  templates should be considered.

  implement generation of multiple languages at a time ? ( ponder dropping this
  feature since I can just run the assembler repeatedly.

  settings the mark at the beginning of the template expansion would be nice
  so that the template can be easily copied. advise looks like a way
  to do this cleanly.

* Major contributions

  .. Toolbox ideas

  Add in some of the old toolbox ideas. Each token should be a
  repository of general programming knowledge. The purpose of
  the templates is to be able to rapidly instantiate that
  knowledge into a particular technique.

  The Compound nature of XML is a good fit for assembling data
  like this.

  implemented description tag which turns the body into extended
  documentation that is stripped. Along with leveraging the
  namespaceURI for language specifics the design is layed out.

  .. Chunks

  Generate "chunks" in template expansion which are incomplete code
  fragments that are loaded into registers or some such temporary
  facility. That way you can use those chunks after the template in
  writing new code.

  .. refactor with parameters

  The ability to mark a region of code and pass it as the value for a
  terminal placeholder. This allows code to be re-factored quickly.

  the ability to supply the parameters to the template function. this
  may involve the creation of a sort of special expand form , where it
  would look like a elisp function, however it would start the
  template expansion with the replacements given as arguments.

  (macro foo bar baz)

  expand it, and have foo bar and baz supplied as the replacement text
  for the subs.

* Long Term

  have the macro assembler generate elisp code instead of the
  definition language, and compile the results directly.

  .. The loader idea

  It is a fundamental assumption throughout else-mode that loading a
  file loads all of the necessary templates. I would much rather load
  them as needed in sets. A loader could be constructed that would
  implement dependencies so that any set can be easily loaded.

  The loader would have to communicate via IPC with emacs to do this.
  It would need to be able to see if a given set is already loaded
  and that can only be done inside emacs.

* Macro ideas

  .. Perl5

  a macro for method creation
  a macro for method invocation
