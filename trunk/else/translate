#! /usr/bin/env perl

#----------------------------------------------------------------------
# translate
# Primary Author: Mike Mattie
# copyright: Mike Mattie (2007)
# License: GPLv3
#----------------------------------------------------------------------

# better argument handling would be good. Currently a mask is required.

our %debug_flags = ();

if ( $ARGV[0] eq "-d" ) {
  # take each of the comma seperated debug flags and make a hash pair
  # out of them
  my @flags = split /,/, ( splice @ARGV,0,2 )[1];
  our %debug_flags = map { ( $_ => 1 ) } @flags;
}

sub debug_switch {
  our %debug_flags;
  my $flag = shift();

  return ( $debug_flags{$flag} ) ? 1 : 0;
}

our $lang_mask = shift( @ARGV );

#----------------------------------------------------------------------
# register
#----------------------------------------------------------------------
package Register;

# The data builder that serializes SAX characters events into variables.
# Conceptually a simple stack for recursion. Each stack element is
# a pointer to a scalar, and a match for end_element events to pop
# the stack.

# @registers  : the stack of pointers.
# pointer     : [ element-name , data-key , data-ref ]

# element-name: is the XML element name so that we know when to pop this
#               sink off the stack.

# data-key    : the hash key, a pointer within the struct so to speak.

# data-ref    : a hash reference, the struct itself.

our @registers = ();

sub dump_stack {
  our @registers;

  print STDERR "register [stack] = ",
    join(",",
         map {
           ( 'ARRAY' eq ref( $_ ) )
             ? join("->", $$_[0], $$_[1] )
             : "recursion = " . $_[0];
         } @registers ),
    "\n";
}

sub is_ptr {
  our @registers;
  my $i = shift();

  unless( defined($i) ) {
    $i = -1;
  }

  ( 'ARRAY' eq ref( $registers[$i] ) )
      ? 1
      : 0;
}

sub is_default {
  our @registers;
  my $i = shift();

  unless( defined($i) ) {
    $i = -1;
  }

  ( 'Register::default' eq ref( $registers[$i] ) )
      ? 1
      : 0;
}

sub default_ref {
  our @registers;

  return ( is_ptr() )
    ? $registers[-1][2]
    : $registers[-1][1]
}

sub ready {
  our @registers;

  ( @registers > 0 && is_ptr() )
    ? 1 : 0;
}

sub push_default_marker {
  my $ref = shift();
  push our @registers, bless [Builder::recursion_level(), $ref ], 'Register::default' ;
}

sub pop_default_marker {
  our @registers;

  unless ( is_default() ) {
    print STDERR "pop_default_marker: top of stack is not a default marker, @registers stack is corrupted\n";
    print STDERR "dumping registers\n";

    print STDERR Dumper( \@registers ), "\n";

    die "Failed ! Register::registers corruption discovered by pop_default_marker\n";
  }

  pop @registers;
}

sub replace_default {
  our @registers;

  my ( $element, $data_key ) = @_;

  # BROWN BAG:

  # element should be a SAX element. Instead it is a scalar that is the name of the element.
  # This is because at the time we call replace-default we have the new element, not the
  # element that started the default.

  # A much better solution would be to store A ElementMatch instance along with the recursion
  # level. This issue should be addressed when ElementMatch is weilded seriously to deal
  # with NamespaceURI.

  # from the top of the register stack search down for a pointer that
  # matches the data-key.

  if ( ::debug_switch( 'register-replace' ) ) {
    print STDERR "replace before",Dumper(\@registers), "\n";
  }

  my $i;
  for( $i = @registers - 1 ;
       $i >= 0 && is_ptr($i) ;
       $i-- ) {

    # when we find the data-key replace the element that we match on.
    if ( $registers[$i][1] eq $data_key ) {
      # replace the old default element with the new one

      $registers[$i][0] = $element;

      # since the default is probably right after the current marker we need to move
      # it to the top of the stack otherwise it will explode when the stack is popped.
      push @registers, splice @registers,$i,1;

      if ( ::debug_switch('register-replace') ) {
        print STDERR "replace after",Dumper(\@registers), "\n";
      }

      return;
    }
  }

  # if we have failed we should be sitting at a current marker.
  unless ( $i > 0 ) {
    print STDERR "default for $data_key could not be found at recursion level: ", $registers[$i][0], "\n";
    die "Failed ! Register::registers corruption discovered by replace_default\n";
  }
}

sub push {
  # push a new pointer onto @registers. The element is given along
  # with the key to write to. data_ref is either specified as a third
  # arguement or when undef the reference of the previous pointer on
  # stack is aliased.

  my ( $element , $data_key , $data_ref ) = @_;

  print STDERR "WARNING ! probable parser noise interpreted as syntax\n"
    if ( $data_key =~  m/^\s*$/ );

  unless ( defined $data_ref ) {
    $data_ref = default_ref();
  }

  push our @registers , [ $element->{LocalName} , $data_key , $data_ref ];
}

sub pop {
  # pop a sink.

  unless ( @registers > 0 ) {
    die "failed ! Register::registers corruption discovered by pop\n";
  }

  unless ( is_ptr() ) {
    die "failed ! Register::registers corruption discovered by pop - attempting to pop a current marker\n";
  }

  pop our @registers;
}

sub recognize {
  # we need a way to determine if a given element is relevant to the current
  # register. This way we can pop the register when the closing tag is
  # encountered.

  our @registers;

  my $element = shift();

  unless ( @registers > 0 && is_ptr() ) {
    return 0;
  }

  return ( ${ $registers[-1] }[0] eq $element->{LocalName} )
    ? 1
    : 0;
}

sub concat {
  # append to the current sink.
  our @registers;

  my ( $data_key , $data_ref ) = ( $registers[-1][1],
                                   $registers[-1][2] );

  my $dribble = shift();

  if ( ::debug_switch('macro-literal') ) {
    print STDERR "register [concat] = $dribble\n";
  }

  if ( ::debug_switch('register') ) {
    print STDERR "register [pointer] = $data_key \@level ", Builder::recursion_level(), "\n";
    dump_stack();
  }

  if ( $data_ref->{$data_key} ) {
    $dribble = $data_ref->{$data_key} . $dribble;
  }

  $data_ref->{$data_key} = $dribble;
}

#----------------------------------------------------------------------
# Builder
#----------------------------------------------------------------------
package Builder;

# Construct the intermediate form usually referred to as 'define' or 'def'.

#----------------------------------------------------------------------
# defines are the syntax tree part.
#----------------------------------------------------------------------

our @defines = ();
our $current_language = '';

sub clone_for_language {
  my $lang = shift();

  # clone the current define for a language specific version.

  # this is actually simple in concept, but somewhat tedious
  # to implement. The first time clone is called make a copy
  # of the current define tree. for each subsequent call return
  # that first tree.

  # for now it's shorted by assuming we are only generating one
  # language at a time. Simply go to the top and mark the language there.

  unless ( $defines[0]->{lang} ) {
    $defines[0]->{lang} = $lang;
  }
}

sub defines_ready {
  return ( @defines ) ? 1 : 0;
}

sub recursion_level {
  our @defines;

  ( @defines > 0 )
    ? scalar our @defines
    : 0;
}

sub define {
  our @defines;
  $defines[-1];
}

sub new_define {
  our @defines;

  my $def = {
    # whenever we nest beyond root call it a placeholder.
    decl => ( @defines ) ? 'placeholder' : 'token',
    lang => $current_language,
  };

  push @defines, $def;

  my $element = shift();
  Register::push( $element , 'description' , $def );
}

use Data::Dumper;

# define complete currently means discard as we are not building
# a tree yet.
sub define_complete {
  our @defines;

  my $def = define();

  unless( defined( $def ) ) {
    die "Absurd. define_complete called on non-existant define\n";
  }

  define_copy_macro( $def );

  if ( ::debug_switch( 'struct' ) ) {
    print STDERR Dumper( $def ) , "\n";
  }

  # When it's time to prototype the error checking put it here so it can be
  # run after all the parsing is complete, and we haven't wrote anything bad
  # yet. We want to emit only the subset that is correct.

  emit::define( $def );
  pop @defines;
}

sub get_placeholder {
  # ghetto. Make a bunch of nested hashes if necessary.
  my $p = shift();

  my $def = define();

  unless( defined( $def ) ) {
    die "Absurd trying to get a non-terminal outside of a definition\n";
  }

  unless ( exists $def->{ptable} ) {
    $def->{ptable} = {};
  }

  my $ptable = $def->{ptable};

  if ( exists $ptable->{$p} ) {
    return $ptable->{$p};
  }

  my $ref = {};
  $ptable->{$p} = $ref;

  $ref;
}

sub define_append_macro {
  my ( $def , $data ) = @_;
  if ( exists $def->{macro} ) {
    push @{ $def->{macro} } , $data;
  }
  else {
    $def->{macro} = [ $data ];
  }
}

sub define_copy_macro {
  # copy from the data "buffer" to the actual macro structure.
  # hopefully the caller waited until all the characters
  # events were sent.

  # clears ->data

  my $def = shift();

  unless( $def->{data} ) {
    return;
  }

  define_append_macro( $def , $def->{data} );
  $def->{data} = '';
}

sub define_insert_ref {
  # flush any literal sequence in the buffer
  my $def = define();
  define_copy_macro( $def );

  define_append_macro( $def , shift() );
}

#----------------------------------------------------------------------
# Syntax
#----------------------------------------------------------------------
package Syntax;

# Syntax does the more sophisticated analysis oriented traversals of the
# intermediate define trees created by Builder::

# Whereas builder looks at the "current" define only, and always traverses
# downwards, Syntax is where the more general and complex traversals of
# a tree are performed for analysis and define generation by inference as
# well as pure spec translation.

# until the stages are seperated Syntax simply aliases Builder's define stack.

*syntax_list = \*Builder::defines;

sub language {
  # go from the top down and get the first lang attribute that can be found.

  foreach my $def (reverse @syntax_list) {
    if ( exists $def->{lang} ) {
      return $def->{lang};
    }
  }

  return undef;
}

sub current_namespace {
  our @syntax_list;

  my @scopes = ();
  map { push @scopes , $_->{name} } @syntax_list;

  @scopes;
}

sub increment_autosub {
  # if the syntax analysis was a real phase it would be possible
  # to prune the defines with autosub=1 . However this is the
  # default count value.

  my $define = shift();

  if ( exists $define->{autosub} ) {
    $define->{autosub}++;
  }
  else {
    $define->{autosub} = 1;
  }
}

sub evaluate_deref {
  # This is a critical design point: where all of the AST rewrites begin.

  # All placeholders are generated as unique. The advantage is that
  # the user can choose unique names when there is a distinction to be
  # made, and not bother with policing unique-ness when it has no
  # impact on function.

  # However there can be multiple references to the same placeholder that
  # is functionally essential, as in the case of the auto-substitute
  # function.

  # To resolve this question evaluation will generate a placeholder
  # unless a existing definition is found. If that definition is
  # functionally compatible the reference will merge: e.g update
  # auto-substitute reference count.

  # If the generated and existing placeholder's are exclusive then
  # the generated placeholder will be named uniquely and returned.

  # This behavior is the concise and flexible without sacrificing
  # correctness , which is do everything the original else-mode
  # definitions could do.

  my $spec = shift();

  # need to split any modififer
  my ( $modifier , $deref ) = $spec->{expr} =~ m/([@])?(.*)/;
#  print STDERR "expr: $expr modifier = $modifier  , deref = $deref\n";

  my $p = Builder::get_placeholder( $deref );

  if ( defined( $modifier ) && $modifier eq '@' ) {
    increment_autosub( $p );
  }

  if ( $spec->{repeat} ) {
    foreach my $copy ( qw/ repeat separator / ) {
      $p->{$copy} = $spec->{$copy};
    }
  }

  $deref;
}

package Syntax::Ref;

sub new {
  shift();

  # the Syntax::Ref constructor is a key point in the design of the
  # assembler.

  # Background:

  # The user constructs a specification of how they want the placeholder
  # to behave and give it a name. Under the else-mode definition language
  # this is specification is spread out in both a place-holder tree written
  # by the user, and the reference to the root of that placeholder tree
  # in a template body.

  # This makes sense where the definition language is so close
  # to the data structure builder.

  # The purpose of assemble is to enhance by generating as much of the
  # definition as possible. The trees of placeholders, wherever
  # possible are no longer written by the user but generated by the
  # assembler.  Things like menus should be generated from a minimal
  # spec given by the user, not coded by the user.

  # To cleanly seperate the gathering of spec (parsing) from
  # generation (AST rewrite) An abstraction barrier is implemented here.

  # The specification is gathered up in a list of pairs. The keys must
  # be defined by Syntax::evaluate_deref to be meaningful.

  my %spec = ( @_ );

  # The context is whatever part of the placeholder specification is
  # orthogonal to the definition of a placeholder.

  # Currently this is wether it is optional or not (killable in
  # emacs-else parlance)

  my $self = bless {
    namespace => [ Syntax::current_namespace() ],

    context => $spec{context},
    repeat => ( $spec{repeat} ) ? 1 : 0,
  }, 'Syntax::Ref';

  delete $spec{context};

  # Syntax::evaluate_deref will evaluate the specification ; modify the
  # AST as necessary to get a unique and valid placeholder name.

  $self->{deref} = Syntax::evaluate_deref( \%spec );

  # return the newly created Syntax::Ref which is the residual of
  # Syntax::evaluate_deref sufficient to generate the reference
  # to the placeholder.

  $self;
}

sub def_generate {
  my $self = shift();

  my $def =
    emit::quote_context( $self->{context},
                         emit::mk_ref_ident( @{ $self->{namespace} } , $self->{deref} ) );

  if ( $self->{repeat} ) {
    $def .= "...";
  }

  $def;
}

#----------------------------------------------------------------------
# emit
#----------------------------------------------------------------------

package emit;

# First the formatting functions for easy access. These functions do
# the translation of generic text into valid syntax, converting or
# flagging it as illegal.

# currently it only converts a little.

sub cnv_to_ident {
  # else names must be upper-case ascii alphas, digits, or underscores.

  join ('_', map {
    $_ =~ s/-/_/g;         # translate all the illegal characters to underscores
    $_;
  }  @_  );
}

sub mk_decl_ident {
  my $ident = cnv_to_ident( @_ );
  uc( $ident );                # uppercase all the alpha characters.
}

sub mk_ref_ident {
  my $ident = cnv_to_ident( @_ );
  lc( $ident );                # lowercase all the alpha characters
}

sub trim_ws {
  my $s = shift();

  $s =~ s/\s+$//;
  $s =~ s/^\s+//;

  $s;
}

sub trim_ws_lines {
  trim: my $tail = pop @_;
  goto trim if ( $tail =~ /^\s*$/ && @_ );

  push @_ , $tail;

  @_;
}

sub quote {
  "\"" . shift() . "\"";
}

sub quote_context {
  my ( $context , $ref ) = @_;

  my @wrap = ();

  if ( $context eq 'required' ) {
    @wrap = ( '{' , '}' );
  }

  return join('',$wrap[0],$ref,$wrap[1]);
}

#----------------------------------------------------------------------
# emit stack.
#----------------------------------------------------------------------

# The recursion involved in doing various re-writes and compilations
# means that writing output directly to a stream during processing
# won't work. serialize at complete definitions with a stack.

our @emit_stack;

# it should not be difficult to convert a placeholder to a token.

sub emit_macro_open {
  our @emit_stack;
  my ( $name , $type ) = @_;

  # the opening stanza deletes a previous definition and then begins a new
  # declaration.

  $kind = mk_decl_ident( $type );

  my $lang = Syntax::language();

  push @emit_stack , <<OPEN_DECL;
DELETE $kind $name -
  /LANGUAGE="$lang" -
DEFINE $kind $name -
  /LANGUAGE="$lang" -
OPEN_DECL

  undef;
}

sub emit_define_close {
  our @emit_stack;
  print STDOUT pop @emit_stack , "END DEFINE\n";
}

sub emit_auto_substitute {
  our @emit_stack;

  my $p = shift();

  if ( exists $p->{autosub} ) {
    my $count = $p->{autosub};

    $emit_stack[-1] .= <<SUBSPEC;
  /AUTO_SUBSTITUTE -
  /SUBSTITUTE_COUNT=$count -
SUBSPEC
  }
  else {
    $emit_stack[-1] .= <<SUBSPEC;
  /NOAUTO_SUBSTITUTE -
SUBSPEC
  }
}

our %repeat_abbrev = (
 h => 'HORIZONTAL',
 v => 'VERTICAL',
 a => 'CONTEXT_DEPENDENT',
  );

sub emit_repeat {
  our @emit_stack , %repeat_abbrev;
  my $p = shift();

  if ( $p->{separator} ) {
    my $sep = $p->{separator};

    $emit_stack[-1] .= <<DUPSPEC;
  /SEPARATOR="$sep" -
DUPSPEC
  }

  if ( $p->{repeat} ) {
    my $dup = $repeat_abbrev{ $p->{repeat} };
    $emit_stack[-1] .= <<DUPSPEC;
  /DUPLICATE="$dup" -
DUPSPEC
  }
}

sub emit_terminal_close {
  our @emit_stack;
  my $description = quote( trim_ws( shift() ) );

  $emit_stack[-1] .= <<TERM_CLOSE;
  /TYPE=TERMINAL
$description
TERM_CLOSE

  emit_define_close();
}

sub emit_nonterminal_open {
  our @emit_stack;
  my $description = quote( trim_ws( shift() ) );

  $emit_stack[-1] .= <<NONTERM_OPEN;
  /DESCRIPTION=$description -
  /TYPE=NONTERMINAL -
NONTERM_OPEN
}

sub emit_body {
  my $def = shift();

  my @lines = split /\n/ ,
    join( '' , map {
      my $text;
      if ( 'Syntax::Ref' eq ref ( $_ ) ) {
        $text = $_->def_generate();
      }
      else {
        $text = $_;
      }
      $text;
    } @{ $def->{macro} } );

  # get rid of both leading and trailing whitespace lines
  @lines = reverse trim_ws_lines( reverse trim_ws_lines( @lines ) );

  $emit_stack[-1] .= join("\n", map { quote( $_ ) } @lines ) . "\n";
}

sub terminal {
  my ( $p , $def ) = @_;

  #print STDERR "placeholder \"$p\"" , "\n";
  my @namespace = ( Syntax::current_namespace() , $p );
  my $name = mk_decl_ident( @namespace );

  # the opening stanza deletes a previous definition and then begins a new
  # declaration.

  emit_macro_open( $name , 'placeholder' );

  # no conversion to token is necessary, has no need of the name feild.
  emit_auto_substitute( $def->{ptable}->{$p} );

  emit_repeat( $def->{ptable}->{$p} );

  emit_terminal_close( $def->{ptable}->{$p}->{description} );
}

sub define {
  my $def = shift();

  # for terminals the name is always capitalized. But for tokens
  # the name is kept in lower case. Rationale:

  # placeholders should be largely invisble when attempting to
  # expand a symbol as a template. The placeholder's are noise
  # when you want a token.

  # Making placeholders all upper-case helps maintain a distinction
  # between implementation (placeholders) and tokens (templates).

  emit_macro_open( $def->{name} , $def->{decl} );

  # Ideally what is in the ptable is all terminal type definitions.
  # anything that is non-terminal should be outside of ptable.

  map {
    # getting some weird garbage from keys , filter the crap until I can find the
    # bug, probably have an odd number of elements in the hash or some such crap.

    if ( $_ !~  m/^\s*$/ ) {
      terminal( $_ , $def );
    }

  } ( keys %{ $def->{ptable} } ) , "\n";

  emit_auto_substitute( $def );

  emit_nonterminal_open( $def->{description} );

  emit_body( $def );
  emit_define_close();
}

#----------------------------------------------------------------------
# DefineFilter
#
# Along with misc XML document parts drop anything that is documentation
# that doesn't end up in the macro definition itself.
#----------------------------------------------------------------------
package XMLFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

sub comment {
  undef;
}

sub xml_decl {
  undef;
}

sub processing_instruction {
  undef;
}

#----------------------------------------------------------------------
# ElementMatch
#----------------------------------------------------------------------
package ElementMatch;

sub new_filter {
  shift();
  bless { @_ } , 'ElementMatch';
}

sub new_drop {
  shift();

  my $spec = shift();
  # initialize the count
  my %copy = ( %$spec , count => 1 );

  bless \%copy , 'ElementMatch';
}

sub matches {
  my ( $self , $element ) = @_;

  # ignore data keys, use all the search keys.
  foreach my $check ( grep { !/count/ } keys %$self ) {
    unless ( $element->{$check}
             && $element->{$check} =~ /$self->{$check}/ ) {
      return 0;
    }
  }

  return 1;
}

sub consume_start {
  my ( $self , $element ) = @_;

  if ( $self->matches( $element ) ) {
    my $self->{count}++;
  }

  # ignore data keys, use all the search keys.
  foreach my $check ( grep { !/count/ } keys %$self ) {
    unless ( $element->{$check}
             && $element->{$check} =~ /$self->{$check}/ ) {
      return;
    }
  }
}

sub consume_end {
  # when this returns true the match object has expired.

  my ( $self , $element )  = @_;

  if( $self->matches( $element ) ) {
    --$self->{count}
  }

 # invert bool , it's not final until it's nil.
 ( $self->{count} ) ? 0 : 1;
}

#----------------------------------------------------------------------
# PruneFilter
#----------------------------------------------------------------------
package PruneFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

# implement a simple matching object for elements

our @blacklist = ();
our $drop = undef;

sub filter {
  our @blacklist;

  my $filter = new_filter ElementMatch( @_ );
  push @blacklist, $filter;

  $filter;
}

sub prune {
  our $drop = new_drop ElementMatch( filter( @_ ) );
}

sub start_element {
  our $drop;
  my ( $self , $element ) = @_;

  if ( $drop ) {
    $drop->consume_start( $element );
    return;
  }

  foreach my $filter ( @blacklist ) {
    if ( $filter->matches( $element ) ) {
      $drop = new_drop ElementMatch( $filter );
      goto zap;
    }
  }

  $self->{Handler}->start_element($element);

 zap: undef;
}

sub end_element {
  our $drop;

  my ( $self , $element ) = @_;

  if ( $drop ) {
    if ( $drop->consume_end( $element ) ) {
      $drop = undef;
    }

    return;
  }

  $self->{Handler}->end_element($element);
}

sub characters {
  our $drop;
  my ( $self , $data ) = @_;

  if ( $drop ) {
    return;
  }

  $self->{Handler}->characters( $data );
}

#----------------------------------------------------------------------
# StripFilter
#
# strip the body from processing for a given element.
#----------------------------------------------------------------------
package StripFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

our @strip_list = ( qw/ else token / );

our @strip_flag = ();
our $level = 0;

sub strip_data {
  our $level, @strip_flag;

  ( @strip_flag && $strip_flag[-1] == $level )
    ? 1
    : 0;
}

sub strip_parent {
  our $level, $strip_flag;
  push @strip_flag, $level - 1;
}

sub start_element {
  our $level++ , @strip_flag;

  my ( $self , $element ) = @_;

  if ( scalar grep { element->{LocalName} eq $_ } @strip_list ) {
    push @strip_flag , $level;
  }

  $self->{Handler}->start_element($element);
}

sub end_element {
  our $level--, @strip_flag;

  while( @strip_flag && $level < @strip_flag[-1] ) {
    pop @strip_flag;
  }

  my ( $self , $element ) = @_;

  $self->{Handler}->end_element($element);
}

sub characters {
  my ( $self , $data ) = @_;

  return if ( strip_data() );
  $self->{Handler}->characters( $data );
}

#----------------------------------------------------------------------
# Assembler
#
# Implement the Assembler. This is actually just SAX event handlers that
# drive AST generation.
#----------------------------------------------------------------------
package Assembler;

use Data::Dumper;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

# elements defined by the translater implementation.
our %defined = (
  token => [ 'Builder::new_define' , 'Builder::define_complete' ],
  name => [ 'name_start' , undef ],
  description => [ 'description_start' , undef ],

  body => [ 'macro_start' , undef ],
  prefix => [ 'prefix_start' , undef ],
  r => [ 'required_start' , undef ],
 );

#----------------------------------------------------------------------
# dispatch_element
#
# look up an element in a table of handlers. Execute the handler if
# a match is found. Unlike the SAX event handlers these are keyed by
# XML elements.
#----------------------------------------------------------------------

sub dispatch_element {
  our %defined;

  my ( $index , $element ) = @_;
  my $name = $element->{LocalName};

  if ( exists $defined{$name} ) {
    my $href = ${ $defined{ $name } }[$index];

    # execute the event handler if there is one.
    &{ $href }( $element ) if ( defined $href );
    return 1;
  }

  return 0;
}

sub dispatch_start { dispatch_element( 0 , @_ ); }
sub dispatch_end { dispatch_element( 1 , @_ ); }

#----------------------------------------------------------------------
# these SAX event handlers need the data_register functions
#----------------------------------------------------------------------

our @languages = split /,/, $main::lang_mask;

sub start_element {
  our @languages;

  my ( $self , $element ) = @_;

  #print STDERR "Dump element ", Dumper( $element ), "\n";

  if ( $element->{NamespaceURI} ) {
    unless ( scalar grep { $element->{NamespaceURI} eq $_ } @languages ) {
      print STDERR "Notice: Language ", $element->{NamespaceURI}, " is not on the guest list.\n";
      PruneFilter::prune( NamespaceURI => $element->{NamespaceURI} );

      return;
    }

    Builder::clone_for_language( $element->{NamespaceURI} );
  }

  return if ( dispatch_start( $element ) );

  # elements not recognized are declaration of placeholders
  # inside of tokens.

  if ( Builder::defines_ready() ) {
    Register::push( $element , 'description' ,
                    Builder::get_placeholder( $element->{LocalName} ) );
  }
}

sub end_element {
  my ( $self , $element ) = @_;

  # The data accumulator needs a signal to stop recording.
  if ( Register::recognize( $element ) ) {
    Register::pop();
  }

  return if dispatch_end( $element );
}

sub characters {
  my ( $self ,  $data ) = @_;

  if ( Register::ready() ) {
    Register::concat( $data->{Data} );
  }
  else {
    $self->{Handler}->characters( $data );
  }
}

sub macro_start {
  my $element = shift();

  # macros begin by recording into ->data. this is basically
  # a input buffer for the macro body that is replicated
  # without interpretation.

  Register::push( $element , 'data' , undef );
}

sub name_start {
  my $element = shift();
  Register::push( $element , 'name' , undef );
}

# description means we want verbose documentation in the document, but we are
# going to create a terse summary for the token definition. Copy this body
# as the summary and strip the body of the parent.
sub description_start {
  my $element = shift();

  StripFilter::strip_parent();
  Register::push( $element, 'description' );
}

# use Data::Dumper;

sub extract_repeat_controls {
  my $element = shift();

  foreach my $spec ( qw/ h v a / ) {
    if ( $element->{Attributes}->{'{}' . $spec}->{Value} ) {

      # set separator and duplicate for repeated placeholders.

      return (
        separator => $element->{Attributes}->{'{}' . $spec}->{Value},
        repeat => $spec,
       )
    }
  }

  return ();
}

sub required_start {
  my $element = shift();

  # need to extract the p attribute. This is our expression.
  my $expr = $element->{Attributes}->{'{}p'}->{Value};

  # Syntax::Ref constructs or modifies the placeholder tree as necessary
  # to create a reference we can insert in the defintion.

  # At this point the specification of the placeholder needs to be complete
  # aside from affects like auto-substitute which are computed by collision.

  my $term = Builder::define_insert_ref( new Syntax::Ref( context => 'required',
                                                          expr => $expr,
                                                          extract_repeat_controls( $element ),
                                                         ));
}

sub prefix_start {
  my $element = shift();
  Register::push( $element, 'prefix' , undef );
}

#----------------------------------------------------------------------
# main
#----------------------------------------------------------------------

package main;

use XML::SAX::Machines qw/Pipeline/;

# A simple architecture for the assembler.

my $tr = Pipeline (
  # standard translation pipeline

  XMLFilter =>                  # Filter to eliminate pure XML document parts.

  PruneFilter =>                # Eliminate undesired languages etc. valid define material
                                # that is eliminated from the syntax.

  StripFilter =>                # a filter that removes the body data from elements that
                                # are purely containers.

  Assembler =>                  # Assemble definitions. Currently constructs a abstract
                                # structure, rewrites it with some conveinences, and
                                # emits declarations.

  \*STDERR                      # Any part of the document that is unhandled after translation
                                # is an error.
 );

PruneFilter::filter( LocalName => qr/span|prefix/ );  # filter unimplemented features.

input_file: foreach my $file ( @ARGV ) {
  unless( -f $file ) {
    print STDERR "file $file not found - Ignoring argument.\n";
    next input_file;
  }

  $tr->parse_uri( $file );
}
