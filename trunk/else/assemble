#! /usr/bin/env perl

#----------------------------------------------------------------------
# Assemble
# Primary Author: Mike Mattie
# copyright: Mike Mattie (2007)
# License: GPLv3
#----------------------------------------------------------------------

use Data::Dumper;

# better argument handling would be good. Currently a mask is required.

our %debug_flags = ();

if ( $ARGV[0] eq "-d" ) {
  # take each of the comma seperated debug flags and make a hash pair
  # out of them
  my @flags = split /,/, ( splice @ARGV,0,2 )[1];
  our %debug_flags = map { ( $_ => 1 ) } @flags;
}

sub debug_switch {
  our %debug_flags;
  my $flag = shift();

  return ( $debug_flags{$flag} ) ? 1 : 0;
}

our $lang_mask = shift( @ARGV );

#----------------------------------------------------------------------
# register
#----------------------------------------------------------------------
package Register;

# The data builder that serializes SAX characters events into variables.
# Conceptually a simple stack for recursion. Each stack element is
# a pointer to a scalar, and a match for end_element events to pop
# the stack.

# @registers  : the stack of pointers.
# pointer     : [ element-name , data-key , data-ref ]

# element-name: is the XML element name so that we know when to pop this
#               sink off the stack.

# data-key    : the hash key, a pointer within the struct so to speak.

# data-ref    : a hash reference, the struct itself.

our @registers = ();

sub reset {
  our @registers = ();
}

sub dump_stack {
  our @registers;

  print STDERR "register [stack] = ",
    join(",",
         map {
           ( 'ARRAY' eq ref( $_ ) )
             ? join("->", $$_[0], $$_[1] )
             : "recursion = " . $_[0];
         } @registers ),
    "\n";
}

sub is_ptr {
  our @registers;
  my $i = shift();

  unless( defined($i) ) {
    $i = -1;
  }

  ( 'ARRAY' eq ref( $registers[$i] ) )
      ? 1
      : 0;
}

sub is_default {
  our @registers;
  my $i = shift();

  unless( defined($i) ) {
    $i = -1;
  }

  ( 'Register::default' eq ref( $registers[$i] ) )
      ? 1
      : 0;
}

sub default_ref {
  our @registers;

  return ( is_ptr() )
    ? $registers[-1][2]
    : $registers[-1][1]
}

sub ready {
  our @registers;

  ( @registers > 0 && is_ptr() )
    ? 1 : 0;
}

sub push_default_marker {
  my $ref = shift();
  push our @registers, bless [Builder::recursion_level(), $ref ], 'Register::default' ;
}

sub pop_default_marker {
  our @registers;

  unless ( is_default() ) {
    print STDERR "pop_default_marker: top of stack is not a default marker, @registers stack is corrupted\n";
    print STDERR "dumping registers\n";

    print STDERR ::Dumper( \@registers ), "\n";

    die "Failed ! Register::registers corruption discovered by pop_default_marker\n";
  }

  pop @registers;
}

sub replace_default {
  our @registers;

  my ( $element, $data_key ) = @_;

  # BROWN BAG:

  # element should be a SAX element. Instead it is a scalar that is the name of the element.
  # This is because at the time we call replace-default we have the new element, not the
  # element that started the default.

  # A much better solution would be to store A ElementMatch instance along with the recursion
  # level. This issue should be addressed when ElementMatch is weilded seriously to deal
  # with NamespaceURI.

  # from the top of the register stack search down for a pointer that
  # matches the data-key.

  if ( ::debug_switch( 'register-replace' ) ) {
    print STDERR "replace before",::Dumper(\@registers), "\n";
  }

  my $i;
  for( $i = @registers - 1 ;
       $i >= 0 && is_ptr($i) ;
       $i-- ) {

    # when we find the data-key replace the element that we match on.
    if ( $registers[$i][1] eq $data_key ) {
      # replace the old default element with the new one

      $registers[$i][0] = $element;

      # since the default is probably right after the current marker we need to move
      # it to the top of the stack otherwise it will explode when the stack is popped.
      push @registers, splice @registers,$i,1;

      if ( ::debug_switch('register-replace') ) {
        print STDERR "replace after",::Dumper(\@registers), "\n";
      }

      return;
    }
  }

  # if we have failed we should be sitting at a current marker.
  unless ( $i > 0 ) {
    print STDERR "default for $data_key could not be found at recursion level: ", $registers[$i][0], "\n";
    die "Failed ! Register::registers corruption discovered by replace_default\n";
  }
}

sub push {
  # push a new pointer onto @registers. The element is given along
  # with the key to write to. data_ref is either specified as a third
  # arguement or when undef the reference of the previous pointer on
  # stack is aliased.

  my ( $element , $data_key , $data_ref ) = @_;

  print STDERR "WARNING ! probable parser noise interpreted as syntax\n"
    if ( $data_key =~  m/^\s*$/ );

  unless ( defined $data_ref ) {
    $data_ref = default_ref();
  }

  push our @registers , [ $element->{LocalName} , $data_key , $data_ref ];
}

sub pop {
  # pop a sink.

  unless ( @registers > 0 ) {
    die "failed ! Register::registers corruption discovered by pop\n";
  }

  unless ( is_ptr() ) {
    die "failed ! Register::registers corruption discovered by pop - attempting to pop a current marker\n";
  }

  pop our @registers;
}

sub recognize {
  # we need a way to determine if a given element is relevant to the current
  # register. This way we can pop the register when the closing tag is
  # encountered.

  our @registers;

  my $element = shift();

  unless ( @registers > 0 && is_ptr() ) {
    return 0;
  }

  return ( ${ $registers[-1] }[0] eq $element->{LocalName} )
    ? 1
    : 0;
}

sub concat {
  # append to the current sink.
  our @registers;

  my ( $data_key , $data_ref ) = ( $registers[-1][1],
                                   $registers[-1][2] );

  my $dribble = shift();

  if ( ::debug_switch('macro-literal') ) {
    print STDERR "register [concat] = $dribble\n";
  }

  if ( ::debug_switch('register') ) {
    print STDERR "register [pointer] = $data_key \@level ", Builder::recursion_level(), "\n";
    dump_stack();
  }

  if ( $data_ref->{$data_key} ) {
    $dribble = $data_ref->{$data_key} . $dribble;
  }

  $data_ref->{$data_key} = $dribble;
}

#----------------------------------------------------------------------
# Builder
#----------------------------------------------------------------------
package Builder;

# Construct the intermediate form usually referred to as 'define' or 'def'.

#----------------------------------------------------------------------
# defines are the syntax tree part.
#----------------------------------------------------------------------

our @defines = ();

sub reset {
  our @defines = ();
}

sub clone_for_language {
  my $lang = shift();

  # clone the current define for a language specific version.

  # this is actually simple in concept, but somewhat tedious
  # to implement. The first time clone is called make a copy
  # of the current define tree. for each subsequent call return
  # that first tree.

  # for now it's shorted by assuming we are only generating one
  # language at a time. Simply go to the top and mark the language there.

  unless ( $defines[0]->{lang} ) {
    $defines[0]->{lang} = $lang;
  }
}

sub defines_ready {
  return ( @defines > 0 ) ? 1 : 0;
}

sub recursion_level {
  our @defines;

  ( @defines > 0 )
    ? scalar @defines
    : 0;
}

sub define {
  our @defines;
  $defines[-1];
}

sub new_define {
  our @defines;

  my $def = {
    # whenever we nest beyond root call it a placeholder.
    decl => ( @defines ) ? 'placeholder' : 'token',
#    lang => $current_language,
  };

  push @defines, $def;

  # set the default marker.

  my $element = shift();

  # the default marker has a reference to the define, this is important to make
  # sure that push will always work correctly without specifying a explicit
  # ref

  Register::push_default_marker( $def );
  Register::push( $element , 'description' );
}

# define complete currently means discard as we are not building
# a tree yet.
sub define_complete {
  our @defines;

  # pop our 'current' marker on the register stack.
  Register::pop_default_marker();

  # pop off the define we have completed.
  my $finish = pop @defines;

  unless( defined( $finish ) ) {
    die "Absurd. define_complete called on non-existant define\n";
  }

  # the trailing literal data from the body of the macro may be lingering
  # in the data buffer.
  define_copy_macro( $finish );

  # if we have reached the root of the tree queue it for Syntax

  unless ( @defines > 0 ) {
    # TODO:

    # When it's time to prototype the error checking put it here so it can be
    # run after all the parsing is complete, and we haven't wrote anything bad
    # yet. We want to emit only the subset that is correct.

    if ( ::debug_switch( 'b-struct' ) ) {
      print STDERR ::Dumper( $finish ) , "\n";
    }

    # BROWN BAG : since the whole cloning for language thing isn't figured out
    # just queue each structure for the Syntax phase. Later the queuing needs to
    # happen for each language instance of a tree.

    Syntax::queue( $finish );
  }
}

sub get_placeholder_for {
  # ghetto. Make a bunch of nested hashes if necessary.

  my ( $p , $def , $ref ) = @_;

  unless( defined( $def ) ) {
    die "Absurd trying to get a non-terminal for a null define\n";
  }

  unless ( exists $def->{ptable} ) {
    $def->{ptable} = {};
  }

  my $ptable = $def->{ptable};

  # already exists case
  if ( exists $ptable->{$p} ) {
    return $ptable->{$p};
  }

  # create new case
  unless ( defined($ref) ) {
    $ref = {};
  }

  $ptable->{$p} = $ref;

  $ref;
}

sub get_placeholder {
  our @defines;

  # we will always get a name minimally.
  my $p = shift();

  # if we still have arguments we are attaching a existing define of some sort.
  my ( $recursion_level, $ref ) = @_;

  if ( $recursion_level ) {
    unless ( $defines[$recusion_level] ) {
      die "invalid token requested by recursion_level: $recursion_level in get_placeholder\n";
    }
  }
  else {
    $recursion_level = -1;
  }

  my $def = $defines[$recursion_level];

  get_placeholder_for( $p , $def , $ref );
}

sub define_append_macro {
  my ( $def , $data ) = @_;
  if ( exists $def->{macro} ) {
    push @{ $def->{macro} } , $data;
  }
  else {
    $def->{macro} = [ $data ];
  }
}

sub define_copy_macro {
  # copy from the data "buffer" to the actual macro structure.
  # hopefully the caller waited until all the characters
  # events were sent.

  # clears ->data

  my $def = shift();

  unless( $def->{data} ) {
    return;
  }

  define_append_macro( $def , $def->{data} );
  $def->{data} = '';
}

sub define_insert {
  # flush any literal sequence in the buffer
  my $def = define();
  define_copy_macro( $def );

  define_append_macro( $def , shift() );
}

#----------------------------------------------------------------------
# Builder::Ref
#----------------------------------------------------------------------
package Builder::Ref;

# references to placeholders contain much of the placeholder spec. This
# object is a specification of how that placeholder is evaluated.

sub new {
  shift();

  # the Builder::Ref constructor is a key point in the design of the
  # assembler.

  # Background:

  # The user constructs a specification of how they want the placeholder
  # to behave and give it a name. Under the else-mode definition language
  # this is specification is spread out in both a place-holder tree written
  # by the user, and the reference to the root of that placeholder tree
  # in a template body.

  # This makes sense where the definition language is so close
  # to the data structure builder.

  # The purpose of assemble is to enhance by generating as much of the
  # definition as possible. The trees of placeholders, wherever
  # possible are no longer written by the user but generated by the
  # assembler.  Things like menus should be generated from a minimal
  # spec given by the user, not coded by the user.

  # To cleanly seperate the gathering of spec (parsing) from
  # generation (AST rewrite) An abstraction barrier is implemented here.

  # The specification is gathered up in a list of pairs. The keys must
  # be defined by Syntax::evaluate_macro_body to be meaningful.

  # The context is whatever part of the placeholder specification is
  # orthogonal to the definition of a placeholder.

  # Currently this is wether it is optional or not (killable in
  # emacs-else parlance)

  # this used to be a real constructor , but now it's been gutted.
  bless {
    @_
  }, 'Builder::Ref';
}

#----------------------------------------------------------------------
# DefineFilter
#
# Along with misc XML document parts drop anything that is documentation
# that doesn't end up in the macro definition itself.
#----------------------------------------------------------------------
package XMLFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

sub comment {
  undef;
}

sub xml_decl {
  undef;
}

sub processing_instruction {
  undef;
}

#----------------------------------------------------------------------
# ElementMatch
#----------------------------------------------------------------------
package ElementMatch;

sub new_filter {
  shift();
  bless { @_ } , 'ElementMatch';
}

sub new_drop {
  shift();

  my $spec = shift();
  # initialize the count
  my %copy = ( %$spec , count => 1 );

  bless \%copy , 'ElementMatch';
}

sub matches {
  my ( $self , $element ) = @_;

  # ignore data keys, use all the search keys.
  foreach my $check ( grep { !/count/ } keys %$self ) {
    unless ( $element->{$check}
             && $element->{$check} =~ /$self->{$check}/ ) {
      return 0;
    }
  }

  return 1;
}

sub consume_start {
  my ( $self , $element ) = @_;

  if ( $self->matches( $element ) ) {
    my $self->{count}++;
  }

  # ignore data keys, use all the search keys.
  foreach my $check ( grep { !/count/ } keys %$self ) {
    unless ( $element->{$check}
             && $element->{$check} =~ /$self->{$check}/ ) {
      return;
    }
  }
}

sub consume_end {
  # when this returns true the match object has expired.

  my ( $self , $element )  = @_;

  if( $self->matches( $element ) ) {
    --$self->{count}
  }

 # invert bool , it's not final until it's nil.
 ( $self->{count} ) ? 0 : 1;
}

#----------------------------------------------------------------------
# PruneFilter
#----------------------------------------------------------------------
package PruneFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

# implement a simple matching object for elements

our @blacklist = ();
our $drop = undef;

sub filter {
  our @blacklist;

  my $filter = new_filter ElementMatch( @_ );
  push @blacklist, $filter;

  $filter;
}

sub prune {
  our $drop = new_drop ElementMatch( filter( @_ ) );
}

sub start_element {
  our $drop;
  my ( $self , $element ) = @_;

  if ( $drop ) {
    $drop->consume_start( $element );
    return;
  }

  foreach my $filter ( @blacklist ) {
    if ( $filter->matches( $element ) ) {
      $drop = new_drop ElementMatch( $filter );
      goto zap;
    }
  }

  $self->{Handler}->start_element($element);

 zap: undef;
}

sub end_element {
  our $drop;

  my ( $self , $element ) = @_;

  if ( $drop ) {
    if ( $drop->consume_end( $element ) ) {
      $drop = undef;
    }

    return;
  }

  $self->{Handler}->end_element($element);
}

sub characters {
  our $drop;
  my ( $self , $data ) = @_;

  if ( $drop ) {
    return;
  }

  $self->{Handler}->characters( $data );
}

#----------------------------------------------------------------------
# StripFilter
#
# strip the body from processing for a given element.
#----------------------------------------------------------------------
package StripFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

our @strip_list = ( qw/ else token / );

our @strip_flag = ();
our $level = 0;

sub strip_data {
  our $level, @strip_flag;

  ( @strip_flag && $strip_flag[-1] == $level )
    ? 1
    : 0;
}

sub strip_parent {
  our $level, $strip_flag;
  push @strip_flag, $level - 1;
}

sub start_element {
  our $level++ , @strip_flag;

  my ( $self , $element ) = @_;

  if ( scalar grep { element->{LocalName} eq $_ } @strip_list ) {
    push @strip_flag , $level;
  }

  $self->{Handler}->start_element($element);
}

sub end_element {
  our $level--, @strip_flag;

  while( @strip_flag && $level < @strip_flag[-1] ) {
    pop @strip_flag;
  }

  my ( $self , $element ) = @_;

  $self->{Handler}->end_element($element);
}

sub characters {
  my ( $self , $data ) = @_;

  return if ( strip_data() );
  $self->{Handler}->characters( $data );
}

#----------------------------------------------------------------------
# Parser
#
# Implement the Parser as SAX event handlers that drive AST generation.
#----------------------------------------------------------------------
package Parser;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

our @languages = split /,/, $main::lang_mask;

# elements defined by the Assembler implementation.
our %defined = (
  token => [ qw/Builder::new_define define_end/ ],
  name => [ qw/name_start name_end/ ],
  description => [ 'description_start' , undef ],

  body => [ 'macro_start', undef ],
  prefix => [ 'prefix_start' , undef ],
  r => [ 'required_start' , undef ],
 );

#----------------------------------------------------------------------
# dispatch_element
#
# look up an element in a table of handlers. Execute the handler if
# a match is found. Unlike the SAX event handlers these are keyed by
# XML elements.
#----------------------------------------------------------------------

sub dispatch_element {
  our %defined;

  my ( $index , $element ) = @_;
  my $name = $element->{LocalName};

  if ( exists $defined{$name} ) {
    my $href = ${ $defined{ $name } }[$index];

    # execute the event handler if there is one.
    &{ $href }( $element ) if ( defined $href );
    return 1;
  }

  return 0;
}

sub dispatch_start { dispatch_element( 0 , @_ ); }
sub dispatch_end { dispatch_element( 1 , @_ ); }

#----------------------------------------------------------------------
# SAX event handlers that drive dispatch_element
#----------------------------------------------------------------------

sub start_element {
  our @languages;

  my ( $self , $element ) = @_;

  #print STDERR "Dump element ", ::Dumper( $element ), "\n";

  if ( $element->{NamespaceURI} ) {
    unless ( scalar grep { $element->{NamespaceURI} eq $_ } @languages ) {
      print STDERR "Notice: Language ", $element->{NamespaceURI}, " is not on the guest list.\n";
      PruneFilter::prune( NamespaceURI => $element->{NamespaceURI} );

      return;
    }

    Builder::clone_for_language( $element->{NamespaceURI} );
  }

  return if ( dispatch_start( $element ) );

  # elements not recognized are declaration of placeholders
  # inside of tokens.

  if ( Builder::defines_ready() ) {
    Register::push( $element , 'description' ,
                    Builder::get_placeholder( $element->{LocalName} ) );
  }
}

sub end_element {
  my ( $self , $element ) = @_;

  # The data accumulator needs a signal to stop recording.
  if ( Register::recognize( $element ) ) {
    Register::pop();
  }

  return if dispatch_end( $element );
}

sub characters {
  my ( $self ,  $data ) = @_;

  if ( Register::ready() ) {
    Register::concat( $data->{Data} );
  }
  else {
    $self->{Handler}->characters( $data );
  }
}

#----------------------------------------------------------------------
# high level event handlers driven by dispatch_element
#----------------------------------------------------------------------

sub define_end {
  # make sure the register gets cleaned up before we finalize with
  # Builder::define_complete.

  my $element = shift();
  if ( Register::recognize( $element ) ) {
    Register::pop();
  }

  Builder::define_complete();
}

sub macro_start {
  my $element = shift();

  # macros begin by recording into ->data. this is basically
  # a input buffer for the macro body that is replicated
  # without interpretation.

  Register::push( $element , 'data' );
}

sub name_start {
  my $element = shift();
  Register::push( $element , 'name' );
}

sub name_end {
  # we cannot attatch a nested define to the parent define until we have the name.
  # so we need to capture the event of </name>, and attatch the child to the parent.

  if( Builder::recursion_level() > 1 ) {
    my $def = Builder::define();
    Builder::get_placeholder( $def->{name} , -2 , $def);
  }
}

# description means we want verbose documentation in the document, but we are
# going to create a terse summary for the token definition. Copy this body
# as the summary and strip the body of the parent.
sub description_start {
  my $element = shift();

  StripFilter::strip_parent();
  Register::replace_default( 'description', 'description' );
}

sub extract_repeat_controls {
  my $element = shift();

  foreach my $spec ( qw/ h v a / ) {
    if ( $element->{Attributes}->{'{}' . $spec}->{Value} ) {

      # set separator and duplicate for repeated placeholders.

      return (
        separator => $element->{Attributes}->{'{}' . $spec}->{Value},
        repeat => $spec,
       )
    }
  }

  return ();
}

sub required_start {
  my $element = shift();

  # need to extract the p attribute. This is our expression.
  my $expr = $element->{Attributes}->{'{}p'}->{Value};

  # Builder::Ref collects the specification for how the placeholder is
  # expanded. This spec is inserted into the ->macro sequence for
  # deferred evaluation during the syntax phase.

  # At this point the specification of the placeholder needs to be complete
  # aside from affects like auto-substitute which are computed by collision.

  my $term = Builder::define_insert( new Builder::Ref( context => 'required',
                                                       expr => $expr,
                                                       extract_repeat_controls( $element ),
                                                      ));
}

sub prefix_start {
  my $element = shift();
  Register::push( $element, 'prefix' , undef );
}

#----------------------------------------------------------------------
# Syntax
#----------------------------------------------------------------------
package Syntax;

our @AST = ();
our $language = '';

# a namespace stack allows me to avoid doing child -> parent linking
# in the AST tree.

our @namespace = ();

sub reset {
  our @AST = ();
  our $language = '';
  our @namespace = ();
}

sub queue {
  # add a tree to the AST list.
  push our @AST , shift();
}

sub reject_tree {
  my ( $reason , $tree ) = shift();
  print STDERR "rejecting AST tree: $reason\n";
  print STDERR ::Dumper($tree);
}

#----------------------------------------------------------------------
# meat
#----------------------------------------------------------------------

# alias the get_placeholder implementation in Builder:: that is
# not specialized for the parse phase.

*get_placeholder = \*Builder::get_placeholder_for;

sub is_node {
  my $v = shift();
  return ( exists $v->{name} ) ? 1 : 0;
}

sub increment_autosub {
  # if the syntax analysis was a real phase it would be possible
  # to prune the defines with autosub=1 . However this is the
  # default count value.

  my $define = shift();

  if ( exists $define->{autosub} ) {
    $define->{autosub}++;
  }
  else {
    $define->{autosub} = 1;
  }
}

sub evaluate_macro_body {
  # This is a critical design point: where all of the AST rewrites begin.

  # All placeholders are generated as unique. The advantage is that
  # the user can choose unique names when there is a distinction to be
  # made, and not bother with policing unique-ness when it has no
  # impact on function.

  # However there can be multiple references to the same placeholder that
  # is functionally essential, as in the case of the auto-substitute
  # function.

  # To resolve this question evaluation will generate a placeholder
  # unless a existing definition is found. If that definition is
  # functionally compatible the reference will merge: e.g update
  # auto-substitute reference count.

  # If the generated and existing placeholder's are exclusive then
  # the generated placeholder will be named uniquely and returned.

  # This behavior is the concise and flexible without sacrificing
  # correctness , which is do everything the original else-mode
  # definitions could do.

  my $tree = shift();

  my $i ; for ( $i = 0 ; $i < @{ $tree->{macro} } ; $i++ ) {
    my $ref = $tree->{macro}[$i];

    # skip over the literal spans in the macro
    next unless ( 'Builder::Ref' eq ref( $ref ) );

    # need to split any modififer
    my ( $modifier , $deref ) = $ref->{expr} =~ m/([@])?(.*)/;
    # print STDERR "expr: $expr modifier = $modifier  , deref = $deref\n";

    my $p = get_placeholder( $deref , $tree );

    # implement autosub computation
    if ( defined( $modifier ) && $modifier eq '@' ) {
      increment_autosub( $p );
    }

    # implement repeat
    if ( $ref->{repeat} ) {
      foreach my $copy ( qw/ repeat separator / ) {
        $p->{$copy} = $ref->{$copy};
      }
    }

    # TODO: here is where menu placeholder generation would go.

    # replace the AST reference with the syntax reference

    delete $ref->{expr};
    $ref->{deref} = $deref;

    $tree->{macro}[$i] = bless $ref , 'Syntax::Ref';
  }
}

sub rewrite_tree {
  our @namespace;

  my $tree = shift();

  # even placeholders that aren't really templates with bodies should
  # have a ->{name} field. Otherwise we are screwed.

  unless ( exists $tree->{name} ) {
    reject_tree( 'toplevel define does not have a name' , $tree );
    return 0;
  }

  # add another level to the namespace.
  push @namespace , $tree->{name};

  if ( exists $tree->{lang} ) {
    our $language = $tree->{lang};
    delete $tree->{lang};
  }

  # no longer need the data buffer. purely a SAX parsing mechanism.
  if ( exists $tree->{data} ) {
    delete $tree->{data};
  }

  foreach my $v ( keys %{ $tree->{ptable} } ) {
    if ( $v =~ m/^\s*$/ ) {
      # getting some weird garbage from keys , filter the crap until I can find the
      # bug, probably have an odd number of elements in the hash or some such crap.

      print STDERR "warning ! deleting \"$v\" garbage key in ptable\n";
      delete $tree->{ptable}->{$_};
      next;
    }

    if ( is_node( $tree->{ptable}->{$v} ) ) {
      unless ( rewrite_tree( $tree->{ptable}->{$v} ) ) {
        delete $tree->{ptable}->{$v};
      }
    }
  }

  if ( exists $tree->{macro} ) {
    evaluate_macro_body( $tree );
  }

  # discard the current namespace level
  pop @namespace;

  return 1;
}

sub rewrite {
  our @AST, $language;

  if ( ::debug_switch( 's-struct' ) ) {
    print STDERR "dumping syntax tree before re-write\n";
    print STDERR ::Dumper( \@AST );
  }

  map {
    if ( rewrite_tree( $_ ) ) {
      Emit::queue( $language , $_ );
    }
  } @AST;

  if ( ::debug_switch( 's-struct' ) ) {
    print STDERR "dumping syntax tree after re-write\n";
    print STDERR ::Dumper( \@AST );
  }
}

#----------------------------------------------------------------------
# Emit
#----------------------------------------------------------------------
package Emit;

#----------------------------------------------------------------------
# emit stack.
#----------------------------------------------------------------------

# The recursion involved in emitting the trees means that writing
# output directly to a stream during processing won't work.
# serialize at complete definitions with a stack.

our @emit_stack;

sub printer {
  push our @emit_stack, join('', @_ );
}


#----------------------------------------------------------------------
# major entry points.
#----------------------------------------------------------------------
our %queue = ();

sub reset {

}

# entry point.

sub queue {
  our %queue;
  my ( $lang, $tree ) = @_;

  if ( exists $queue{lang} ) {
    push @{ $queue{$lang} } , $tree;
  }
  else {
    $queue{$lang} = [ $tree ];
  }
}

sub generate {


}

#----------------------------------------------------------------------
# main
#----------------------------------------------------------------------

package main;

sub reset_all_phases {
  Register::reset();
  Builder::reset();
  Syntax::reset();
  Emit::reset();
}

use XML::SAX::Machines qw/Pipeline/;

# A simple architecture for the assembler.

my $tr = Pipeline (
  # standard translation pipeline

  XMLFilter =>                  # Filter to eliminate pure XML document parts.

  PruneFilter =>                # Eliminate undesired languages etc. valid define material
                                # that is eliminated from the syntax.

  StripFilter =>                # a filter that removes the body data from elements that
                                # are purely containers.

  Parser =>                     # Parse definitions. Currently constructs a abstract
                                # structure

  \*STDERR                      # Any part of the document that is unhandled after translation
                                # is an error.
 );

PruneFilter::filter( LocalName => qr/span|prefix/ );  # filter unimplemented features.

input_file: foreach my $file ( @ARGV ) {
  unless( -f $file ) {
    print STDERR "file $file not found - Ignoring argument.\n";
    next input_file;
  }

  reset_all_phases();

  $tr->parse_uri( $file );

  Syntax::rewrite();

  # emit the definitions we have queued
  #Emit::generate();
}
