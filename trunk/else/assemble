#! /usr/bin/env perl

#----------------------------------------------------------------------
# Assemble
# Primary Author: Mike Mattie
# copyright: Mike Mattie (2007)
# License: GPLv3
#----------------------------------------------------------------------

# Assemble is a program that translates else-mode macros in a XML document
# form to forms that are interpretable by Emacs. To do this it needs to
# filter the template definitions from the document and generate the
# templates.

# My two practical XML choices are either DOM or SAX. Both of these
# choices are horrible. DOM is redicilous for the task because it is
# not necessary to have the entire document in memory. SAX is horrible
# because it is state-less and event driven.

# SAX is the lesser of the two evils in this case. In fact the right
# thing would be coupling the parser and the consumer with co-routines
# but evidently that makes stack based brains explode.

unless ( @ARGV > 0 ) {
  print STDERR <<HOWTO;
assemble [language,...] [input-file]....

Assemble translates a XML input format to else-mode template
definitions.

The first arguement is the language to generate. the XML format
allows more than one language definition for a given template,
this arguement chooses which language will be emitted.

input-file... is a list of XML input files to process.
HOWTO
}

#----------------------------------------------------------------------
# debugging support
#----------------------------------------------------------------------

# currently the user can pass a list of debug switches as the first
# arguement seperated by ','
#
# example: -d s-struct,e-struct

use Data::Dumper;
use Carp;

#----------------------------------------------------------------------
# Settings
#----------------------------------------------------------------------
package Settings;

our %debug_flags = ();

if ( $ARGV[0] eq "-d" ) {
  # take each of the comma seperated debug flags and make a hash pair
  # out of them
  my @flags = split /,/, ( splice @ARGV,0,2 )[1];
  our %debug_flags = map { ( $_ => 1 ) } @flags;
}

sub debug {
  # return true if we have any debugging switches set.
  our %debug_flags;

  ( scalar %debug_flags ) ? 1 : 0;
}

sub debug_switch {
  # given a string that should be a debug switch ask if it was
  # enabled by the user.

  our %debug_flags;
  my $flag = shift();

  return ( $debug_flags{$flag} ) ? 1 : 0;
}

our $emit_for_language = shift( @ARGV );

#----------------------------------------------------------------------
# register
#----------------------------------------------------------------------

# The data builder that serializes SAX characters events into variables.

# I named it register because I needed a accumulator for SAX events,
# and having wrote intel assembler back in the day "ax" popped into
# my head.

# The primary purpose of Register is to answer the question: where does
# this go? for data delivered by characters SAX events.

# The main functions are: push,pop, recognize, and concat.

# push,pop allow you to recurse into new variables to stuff data.

# recognize is a necessary evil; you must pass element events
# to recognize so that the registers stack can be kept in sync
# with the document nesting. recognize should only be passed
# closing tags, or "end" SAX events.

#----------------------------------------------------------------------

package Register;
our @registers = ();              # the core stack data structure.

# Conceptually a simple stack for recursion. Each stack element is
# a pointer, and a match for end_element events to pop the stack.

# There are two element types that live in the registers stack. scopes
# and pointers.

# pointer     : [ element-name , data-key , data-ref ]
# scope       : [ recursion-level, data-ref ]

# The pointer combines a hash reference, a hash key, and a element
# name allowing character data to be delivered to an arbitrary
# hash.

# The scope is much different with a recursion-level, and a hash reference.
# It serves as the default root of a tree of pointers (children).

sub reset {
  # clear any global variables in this namespace.

  our @registers = ();
}

sub dump_stack {
  # print a dump of the @registers stack for debugging and diagnostics.

  our @registers;

  print STDERR "register [stack] = ",
    join(",",
         map {
           ( 'ARRAY' eq ref( $_ ) )
             ? join("->", $$_[0], $$_[1] )
             : "recursion = " . $_[0];
         } @registers ),
    "\n";
}

# distinguish between the two types of stack elements.

sub is_ptr {
  our @registers;
  my $i = shift();

  unless( defined($i) ) {
    $i = -1;
  }

  ( 'ARRAY' eq ref( $registers[$i] ) )
      ? 1
      : 0;
}

sub is_scope {
  our @registers;
  my $i = shift();

  unless( defined($i) ) {
    $i = -1;
  }

  ( 'Register::scope' eq ref( $registers[$i] ) )
      ? 1
      : 0;
}

sub default_ref {
  # return a default reference with element type ambiguity.
  our @registers;

  return ( is_ptr() )
    ? $registers[-1][2]
    : $registers[-1][1]
}

# push/pop scope elements.

# This is an opportunity to detect stack corruption which is actually
# the parser losing synchronization with the recursion of nested
# elements.

sub push_scope {
  my $ref = shift();
  push our @registers, bless [Builder::recursion_level(), $ref ], 'Register::scope' ;
}

sub pop_scope {
  our @registers;

  unless ( is_scope() ) {
    print STDERR "Register::pop_scope: top of stack is not a scope, stack is corrupted\n";
    dump_stack();

    die "Failed ! Register corruption discovered by pop_scope\n";
  }

  pop @registers;
}

sub replace_default {
  our @registers;

  my ( $element, $data_key ) = @_;

  # BROWN BAG:

  # element should be a SAX element. Instead it is a scalar that is
  # the name of the element.  At the time we call replace-default we
  # have the new element, not the element that started the default.

  # A much better solution: Store an ElementMatch instance along with
  # the recursion level. This issue should be addressed when
  # ElementMatch is weilded seriously to deal with NamespaceURI.

  # from the top of the register stack search down for a pointer that
  # matches the data-key.

  if ( Settings::debug_switch( 'register-replace' ) ) {
    print STDERR "replace before",::Dumper(\@registers), "\n";
  }

  my $i;
  for( $i = @registers - 1 ;
       $i >= 0 && is_ptr($i) ;
       $i-- ) {

    # when we find the data-key replace the element that we match on.
    if ( $registers[$i][1] eq $data_key ) {
      # replace the old default element with the new one

      $registers[$i][0] = $element;

      # since the default is probably right after the current marker we need to move
      # it to the top of the stack otherwise it will explode when the stack is popped.
      push @registers, splice @registers,$i,1;

      if ( Settings::debug_switch('register-replace') ) {
        print STDERR "replace after",::Dumper(\@registers), "\n";
      }

      return;
    }
  }

  # if we have failed we should be sitting at a current marker.
  unless ( $i > 0 ) {
    print STDERR "default for $data_key could not be found at recursion level: ", $registers[$i][0], "\n";
    die "Failed ! Register corruption discovered by replace_default\n";
  }
}

sub ready {
  # return true if a subsequent concat operation is valid. register stack must
  # be non-empty with a pointer type element on the top.

  our @registers;

  ( @registers > 0 && is_ptr() )
    ? 1 : 0;
}


sub push {
  # push a new pointer onto @registers. The element is given along
  # with the key to write to. data_ref is either specified as a third
  # arguement or when undef the reference of the previous pointer on
  # stack is aliased.

  my ( $element , $data_key , $data_ref ) = @_;

  print STDERR "WARNING ! probable parser noise interpreted as syntax\n"
    if ( $data_key =~  m/^\s*$/ );

  unless ( defined $data_ref ) {
    $data_ref = default_ref();
  }

  push our @registers , [ $element->{LocalName} , $data_key , $data_ref ];
}

sub pop {
  # pop a pointer.

  unless ( @registers > 0 ) {
    die "failed ! Register corruption discovered by pop\n";
  }

  unless ( is_ptr() ) {
    die "failed ! Register corruption discovered by pop - attempting to pop a current marker\n";
  }

  pop our @registers;
}

sub recognize {
  # we need a way to determine if a given element is relevant to the current
  # register. This way we can pop the register when the closing tag is
  # encountered.

  our @registers;

  my $element = shift();

  unless ( @registers > 0 && is_ptr() ) {
    return 0;
  }

  return ( ${ $registers[-1] }[0] eq $element->{LocalName} )
    ? 1
    : 0;
}

sub concat {
  # append to the hash/key indicated by the pointer on the top
  # of the register stack.

  our @registers;

  unless ( ready() && is_ptr() ) {
    die "failed ! Register corruption discovered by concat - top of stack is not a pointer\n";
  }

  my ( $data_key , $data_ref ) = ( $registers[-1][1],
                                   $registers[-1][2] );

  my $dribble = shift();

  if ( Settings::debug_switch('macro-literal') ) {
    print STDERR "register [concat] = $dribble\n";
  }

  if ( Settings::debug_switch('register') ) {
    print STDERR "register [pointer] = $data_key \@level ", Builder::recursion_level(), "\n";
    dump_stack();
  }

  if ( $data_ref->{$data_key} ) {
    $dribble = $data_ref->{$data_key} . $dribble;
  }

  $data_ref->{$data_key} = $dribble;
}

#----------------------------------------------------------------------
# Traverse
#----------------------------------------------------------------------

# Traverse the tree form applying transform functions to rewrite the
# tree.

# Both depth-first and breadth-first traversals are supplied. The
# traversals can also keep a list of all the vertice "names" during
# the recursion to generate unique names for vertices.

#----------------------------------------------------------------------
package Traverse;

sub with_ns {
  # create a traversal with namespace tracking.

  my ( undef , $root ) = splice @_,0,2;

  unless ( exists $root->{name} ) {
    die "Traverse::depth_first root does not have a name attached\n";
  }

  bless {
    root => $root,
    ns => [ $root->{name} ],
  }, 'Traverse';
}

sub simple {
  # create a traversal without namespace tracking.

  my ( undef , $root ) = splice @_,0,2;

  bless {
    root => $root,
    apply => [ @_ ],
  }, 'Traverse';
}

sub ns {
  my $self = shift();
  @{ $self->{ns} };
}

sub pop_ns {
  my $self = shift();

  return unless( exists $self->{ns} );

  if ( @{ $self->{ns} } > 1 ) {
    pop @{ $self->{ns} };
  }
}

sub is_node {
  my $v = shift();
  return ( exists $v->{ptable} ) ? 1 : 0;
}

sub drop_child {
  my ( $reason , $tree , $child ) = @_;

  # verbosity control for this message should go here.

  print STDERR "pruning AST tree: $reason\n";
  print STDERR ::Dumper($tree);

  delete $tree->{$child};
}

sub apply {
  my ( $self, $vertex ) = splice @_,0,2;

  map {
    my $drop = &{ $_ }( $self , $vertex );

    if ( defined ( $drop ) && $drop ) {
      return $drop;
    }

  } @{ $self->{apply} };

  undef;
}

sub walk_children {
  my ( $self, $vertex, $recursion ) = @_;

  # seek depth by recursing first.
  if ( exists $vertex->{ptable} ) {
    my $ptable = $vertex->{ptable};

    foreach my $child ( keys %{$ptable} ) {

      if ( $child =~ m/^\s*$/ ) {
        # getting some weird garbage from keys , filter the crap until I can find the
        # bug, probably have an odd number of elements in the hash or some such crap.

        drop_child( "warning ! deleting \"$child\" garbage key in ptable", $ptable, $child);
        next;
      }

      # recurse, updating ns if we are tracking namespaces
      push @{ $self->{ns} } , $child if ( exists $self->{ns} );

      # the functions applied to the vertices will have a reference
      # to the vertex they operate on. They can modify the tree
      # directly.

      # The one thing a function can't do is modify the ptable of
      # the vertex's parent.

      my $drop = &{ $recursion }( $self, $ptable->{$child}, @_ );

      if ( defined( $drop ) && $drop ) {
        drop_child( $drop , $ptable, $child );
      }
    }

    # if all the children are pruned remove ->ptable, so the is_node test
    # will work correctly.

    unless ( keys %{$ptable} > 0 ) {
      delete $vertex->{ptable};
    }
  }

  undef;
}

sub depth_first {
  my ( $self , $vertex ) = @_;

  $self->walk_children( $vertex, \&depth_first );

  my $drop = $self->apply( $vertex );

  $self->pop_ns();
  $drop;
}

sub breadth_first {
  my ( $self , $vertex ) = @_;

  my $drop = $self->apply( $vertex );

  unless ( defined( $drop ) && $drop ) {
    $self->walk_children( $vertex, \&breadth_first );
  }

  $self->pop_ns();
  $drop;
}

sub apply_depth_first {
  my $self = shift();

  $self->{apply} = [ @_ ];
  $self->depth_first( $self->{root} )
}


sub apply_breadth_first {
  my $self = shift();

  $self->{apply} = [ @_ ];
  $self->breadth_first( $self->{root} )
}

#----------------------------------------------------------------------
# Builder
#----------------------------------------------------------------------

# Construct a parse form of the define tree. The core data structure
# is a stack where the top of the stack is the current define.

#----------------------------------------------------------------------

package Builder;

our @defines = ();

sub reset {
  our @defines = ();
}

sub recursion_level {

  our @defines;

  ( @defines > 0 )
    ? scalar @defines
    : 0;
}

sub new_define {
  our @defines;

  my $def = {
    # whenever we nest beyond root call it a placeholder.
    decl => ( @defines ) ? 'placeholder' : 'token',
#    lang => $current_language,
  };

  push @defines, $def;

  # set the default marker.

  my $element = shift();

  # the default marker has a reference to the define, this is important to make
  # sure that push will always work correctly without specifying a explicit
  # ref

  Register::push_scope( $def );
  Register::push( $element , 'description' );
}

#----------------------------------------------------------------------
# @defines must be non-empty, check with ready()
#----------------------------------------------------------------------
sub ready {
  return ( @defines > 0 ) ? 1 : 0;
}

sub define {
  our @defines;
  $defines[-1];
}

# define complete currently means discard as we are not building
# a tree yet.
sub define_complete {
  our @defines;

  # pop our 'current' marker on the register stack.
  Register::pop_scope();

  # pop off the define we have completed.
  my $finish = pop @defines;

  unless( defined( $finish ) ) {
    die "Absurd. define_complete called on non-existant define\n";
  }

  # the trailing literal data from the body of the macro may be lingering
  # in the data buffer.
  define_copy_macro( $finish );

  # remove parsing artifacts from the tree.

  # if we have reached the root of the tree queue it for Syntax

  if ( @defines < 1 ) {
    my $cleanup = simple Traverse( $finish );

    $cleanup->apply_depth_first(
      sub {
        my ( $t , $v ) = @_;

        # no longer need the data buffer. purely a SAX parsing mechanism.
        if ( exists $v->{data} ) {
          delete $v->{data};
        }

        undef;
      }
     );

    # TODO:

    # When it's time to prototype the error checking put it here so it can be
    # run after all the parsing is complete, and we haven't wrote anything bad
    # yet. We want to emit only the subset that is correct.

    if ( Settings::debug_switch( 'b-struct' ) ) {
      print STDERR ::Dumper( $finish ) , "\n";
    }

    # queue for rewrite
    Syntax::queue( $finish );
  }
}

sub get_placeholder_for {
  # ghetto. Make a bunch of nested hashes if necessary.

  my ( $p , $def , $ref ) = @_;

  unless( defined( $def ) ) {
    die "Absurd trying to get a non-terminal for a null define\n";
  }

  unless ( exists $def->{ptable} ) {
    $def->{ptable} = {};
  }

  my $ptable = $def->{ptable};

  # already exists case
  if ( exists $ptable->{$p} ) {
    return $ptable->{$p};
  }

  # create new case
  unless ( defined($ref) ) {
    $ref = {};
  }

  $ptable->{$p} = $ref;

  $ref;
}

sub get_placeholder {
  our @defines;

  # we will always get a name minimally.
  my $p = shift();

  # if we still have arguments we are attaching a existing define of some sort.
  my ( $recursion_level, $ref ) = @_;

  if ( $recursion_level ) {
    unless ( $defines[$recusion_level] ) {
      die "invalid token requested by recursion_level: $recursion_level in get_placeholder\n";
    }
  }
  else {
    $recursion_level = -1;
  }

  my $def = $defines[$recursion_level];

  get_placeholder_for( $p , $def , $ref );
}

sub define_append_macro {
  my ( $def , $data ) = @_;
  if ( exists $def->{macro} ) {
    push @{ $def->{macro} } , $data;
  }
  else {
    $def->{macro} = [ $data ];
  }
}

sub define_copy_macro {
  # copy from the data "buffer" to the actual macro structure.
  # hopefully the caller waited until all the characters
  # events were sent.

  # clears ->data

  my $def = shift();

  unless( $def->{data} ) {
    return;
  }

  define_append_macro( $def , $def->{data} );
  $def->{data} = '';
}

sub define_insert {
  # flush any literal sequence in the buffer
  my $def = define();
  define_copy_macro( $def );

  define_append_macro( $def , shift() );
}

#----------------------------------------------------------------------
# Builder::Ref
#----------------------------------------------------------------------
package Builder::Ref;

# references to placeholders contain much of the placeholder spec. This
# object is a specification of how that placeholder is evaluated.

sub new {
  shift();

  # the Builder::Ref constructor is a key point in the design of the
  # assembler.

  # Background:

  # The user constructs a specification of how they want the placeholder
  # to behave and give it a name. Under the else-mode definition language
  # this is specification is spread out in both a place-holder tree written
  # by the user, and the reference to the root of that placeholder tree
  # in a template body.

  # This makes sense where the definition language is so close
  # to the data structure builder.

  # The purpose of assemble is to enhance by generating as much of the
  # definition as possible. The trees of placeholders, wherever
  # possible are no longer written by the user but generated by the
  # assembler.  Things like menus should be generated from a minimal
  # spec given by the user, not coded by the user.

  # To cleanly seperate the gathering of spec (parsing) from
  # generation (AST rewrite) An abstraction barrier is implemented here.

  # The specification is gathered up in a list of pairs. The keys must
  # be defined by Syntax::evaluate_macro_body to be meaningful.

  # The context is whatever part of the placeholder specification is
  # orthogonal to the definition of a placeholder.

  # Currently this is wether it is optional or not (killable in
  # emacs-else parlance)

  # this used to be a real constructor , but now it's been gutted.
  bless {
    @_
  }, 'Builder::Ref';
}

#----------------------------------------------------------------------
# DefineFilter
#
# Along with misc XML document parts drop anything that is documentation
# that doesn't end up in the macro definition itself.
#----------------------------------------------------------------------
package XMLFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

sub comment {
  undef;
}

sub xml_decl {
  undef;
}

sub processing_instruction {
  undef;
}

#----------------------------------------------------------------------
# ElementMatch
#----------------------------------------------------------------------
package ElementMatch;

sub new_filter {
  shift();
  bless { @_ } , 'ElementMatch';
}

sub new_drop {
  shift();

  my $spec = shift();
  # initialize the count
  my %copy = ( %$spec , count => 1 );

  bless \%copy , 'ElementMatch';
}

sub matches {
  my ( $self , $element ) = @_;

  # ignore data keys, use all the search keys.
  foreach my $must_match ( grep { !/count/ } keys %$self ) {
    unless ( $element->{$must_match}
             && $element->{$must_match} =~ /$self->{$must_match}/ ) {
      return 0;
    }
  }

  return 1;
}

sub consume_start {
  my ( $self , $element ) = @_;

  if ( $self->matches( $element ) ) {
    my $self->{count}++;
  }

  # ignore data keys, use all the search keys.
  foreach my $check ( grep { !/count/ } keys %$self ) {
    unless ( $element->{$check}
             && $element->{$check} =~ /$self->{$check}/ ) {
      return;
    }
  }
}

sub consume_end {
  # when this returns true the match object has expired.

  my ( $self , $element )  = @_;

  if( $self->matches( $element ) ) {
    --$self->{count}
  }

 # invert bool , it's not final until it's nil.
 ( $self->{count} ) ? 0 : 1;
}

#----------------------------------------------------------------------
# PruneFilter
#----------------------------------------------------------------------
package PruneFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

# implement a simple matching object for elements

our @blacklist = ();
our $drop = undef;

sub filter {
  our @blacklist;

  my $filter = new_filter ElementMatch( @_ );
  push @blacklist, $filter;

  $filter;
}

sub prune {
  our $drop = new_drop ElementMatch( filter( @_ ) );
}

sub start_element {
  our $drop;
  my ( $self , $element ) = @_;

  if ( $drop ) {
    $drop->consume_start( $element );
    return;
  }

  foreach my $filter ( @blacklist ) {
    if ( $filter->matches( $element ) ) {
      $drop = new_drop ElementMatch( $filter );
      goto zap;
    }
  }

  $self->{Handler}->start_element($element);

 zap: undef;
}

sub end_element {
  our $drop;

  my ( $self , $element ) = @_;

  if ( $drop ) {
    if ( $drop->consume_end( $element ) ) {
      $drop = undef;
    }

    return;
  }

  $self->{Handler}->end_element($element);
}

sub characters {
  our $drop;
  my ( $self , $data ) = @_;

  if ( $drop ) {
    return;
  }

  $self->{Handler}->characters( $data );
}

#----------------------------------------------------------------------
# StripFilter
#
# strip the body from processing for a given element.
#----------------------------------------------------------------------
package StripFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

our @strip_list = ( qw/ else token / );

our @strip_flag = ();
our $level = 0;

sub strip_data {
  our $level, @strip_flag;

  ( @strip_flag && $strip_flag[-1] == $level )
    ? 1
    : 0;
}

sub strip_parent {
  our $level, $strip_flag;
  push @strip_flag, $level - 1;
}

sub start_element {
  our $level++ , @strip_flag;

  my ( $self , $element ) = @_;

  if ( scalar grep { element->{LocalName} eq $_ } @strip_list ) {
    push @strip_flag , $level;
  }

  $self->{Handler}->start_element($element);
}

sub end_element {
  our $level--, @strip_flag;

  while( @strip_flag && $level < @strip_flag[-1] ) {
    pop @strip_flag;
  }

  my ( $self , $element ) = @_;

  $self->{Handler}->end_element($element);
}

sub characters {
  my ( $self , $data ) = @_;

  return if ( strip_data() );
  $self->{Handler}->characters( $data );
}

#----------------------------------------------------------------------
# Parser
#
# Implement the Parser as SAX event handlers that drive AST generation.
#----------------------------------------------------------------------
package Parser;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

# elements defined by the Assembler implementation.
our %defined = (
  token => [ qw/Builder::new_define define_end/ ],
  name => [ qw/name_start name_end/ ],
  description => [ 'description_start' , undef ],

  body => [ 'macro_start', undef ],
  prefix => [ 'prefix_start' , undef ],
  r => [ 'required_start' , undef ],
  o => [ 'optional_start' , undef ],
 );

#----------------------------------------------------------------------
# dispatch_reserved
#
# look up an element in a table of handlers. Execute the handler if
# a match is found. Unlike the SAX event handlers these are keyed by
# XML elements.
#----------------------------------------------------------------------

sub dispatch_reserved {
  our %defined;

  my ( $index , $element ) = @_;
  my $name = $element->{LocalName};

  if ( exists $defined{$name} ) {
    my $href = ${ $defined{ $name } }[$index];

    # execute the event handler if there is one.
    &{ $href }( $element ) if ( defined $href );
    return 1;
  }

  return 0;
}

sub dispatch_reserved_start { dispatch_reserved( 0 , @_ ); }
sub dispatch_reserved_end { dispatch_reserved( 1 , @_ ); }

#----------------------------------------------------------------------
# SAX event handlers that drive dispatch_element
#----------------------------------------------------------------------

sub start_element {
  my ( $self , $element ) = @_;

  #print STDERR "Dump element ", ::Dumper( $element ), "\n";

  if ( $element->{NamespaceURI} ) {
    unless ( $element->{NamespaceURI} eq $Settings::emit_for_language ) {
      if ( Settings::debug() ) {
        print STDERR "Notice: Language ", $element->{NamespaceURI}, " is not on the guest list.\n";
      }
      PruneFilter::prune( NamespaceURI => $element->{NamespaceURI} );

      return;
    }
  }

  return if ( dispatch_reserved_start( $element ) );

  # elements not recognized are declaration of placeholders
  # inside of tokens.

  if ( Builder::ready() ) {
    Register::push( $element , 'description' ,
                    Builder::get_placeholder( $element->{LocalName} ) );
  }
}

sub end_element {
  my ( $self , $element ) = @_;

  # The data accumulator needs a signal to stop recording.
  if ( Register::recognize( $element ) ) {
    Register::pop();
  }

  return if dispatch_reserved_end( $element );
}

sub characters {
  my ( $self ,  $data ) = @_;

  if ( Register::ready() ) {
    Register::concat( $data->{Data} );
  }
  else {
    # send any unhandled data on for debugging only if we are debugging.
    if ( Settings::debug() ) {
      $self->{Handler}->characters( $data );
    }
  }
}

#----------------------------------------------------------------------
# high level event handlers driven by dispatch_element
#----------------------------------------------------------------------

sub define_end {
  # make sure the register gets cleaned up before we finalize with
  # Builder::define_complete.

  my $element = shift();
  if ( Register::recognize( $element ) ) {
    Register::pop();
  }

  Builder::define_complete();
}

sub macro_start {
  my $element = shift();

  # macros begin by recording into ->data. this is basically
  # a input buffer for the literal parts of the macro body.

  Register::push( $element , 'data' );
}

sub name_start {
  my $element = shift();
  Register::push( $element , 'name' );
}

sub name_end {
  # we cannot attatch a nested define to the parent define until we have the name.
  # so we need to capture the event of </name>, and attatch the child to the parent.

  if( Builder::recursion_level() > 1 ) {
    my $def = Builder::define();
    Builder::get_placeholder( $def->{name} , -2 , $def);
  }
}

# description means we want verbose documentation in the document, but we are
# going to create a terse summary for the token definition. Copy this body
# as the summary and strip the body of the parent.
sub description_start {
  my $element = shift();

  StripFilter::strip_parent();
  Register::replace_default( 'description', 'description' );
}

sub extract_repeat_controls {
  my $element = shift();

  foreach my $spec ( qw/ h v a / ) {
    if ( $element->{Attributes}->{'{}' . $spec}->{Value} ) {

      # set separator and duplicate for repeated placeholders.
      return (
        separator => $element->{Attributes}->{'{}' . $spec}->{Value},
        repeat => $spec,
       )
    }
  }

  return ();
}

sub extract_placeholder_expr {
  my $element = shift();

  # currently implements p="" only
  $element->{Attributes}->{'{}p'}->{Value};
}

sub required_start {
  my $element = shift();

  # gather the attributes in the element into keys recognized by
  # Builder::Ref

  Builder::define_insert( new Builder::Ref( context => 'required',
                                            expr => extract_placeholder_expr( $element ),
                                            extract_repeat_controls( $element ),
                                           ));
}

sub optional_start {
  my $element = shift();

  Builder::define_insert( new Builder::Ref( context => 'optional',
                                            expr => extract_placeholder_expr( $element ),
                                            extract_repeat_controls( $element ),
                                           ));
}

sub prefix_start {
  my $element = shift();
  Register::push( $element, 'prefix' , undef );
}

#----------------------------------------------------------------------
# Syntax
#----------------------------------------------------------------------
package Syntax;

our @AST = ();

sub reset {
  our @AST = ();
}

sub queue {
  # add a tree to the AST list.
  push our @AST , shift();
}

#----------------------------------------------------------------------
# meat
#----------------------------------------------------------------------

# alias the get_placeholder implementation in Builder:: that is
# not specialized for the parse phase.

*get_placeholder = \*Builder::get_placeholder_for;

sub increment_autosub {
  # if the syntax analysis was a real phase it would be possible
  # to prune the defines with autosub=1 . However this is the
  # default count value.

  my $define = shift();

  if ( exists $define->{autosub} ) {
    $define->{autosub}++;
  }
  else {
    $define->{autosub} = 1;
  }
}

sub evaluate_macro_body {
  # This is a critical design point: where all of the AST rewrites begin.

  # All placeholders are generated as unique. The advantage is that
  # the user can choose unique names when there is a distinction to be
  # made, and not bother with policing unique-ness when it has no
  # impact on function.

  # However there can be multiple references to the same placeholder that
  # is functionally essential, as in the case of the auto-substitute
  # function.

  # To resolve this question evaluation will generate a placeholder
  # unless a existing definition is found. If that definition is
  # functionally compatible the reference will merge: e.g update
  # auto-substitute reference count.

  # If the generated and existing placeholder's are exclusive then
  # the generated placeholder will be named uniquely and returned.

  # This behavior is the concise and flexible without sacrificing
  # correctness , which is do everything the original else-mode
  # definitions could do.

  my $v = shift();

  my $i ; for ( $i = 0 ; $i < @{ $v->{macro} } ; $i++ ) {
    my $ref = $v->{macro}[$i];

    # skip over the literal spans in the macro
    next unless ( 'Builder::Ref' eq ref( $ref ) );

    # need to split any modififer
    my ( $modifier , $deref ) = $ref->{expr} =~ m/([@])?(.*)/;
    # print STDERR "expr: $expr modifier = $modifier  , deref = $deref\n";

    my $p = get_placeholder( $deref , $v );

    # implement autosub computation
    if ( defined( $modifier ) && $modifier eq '@' ) {
      increment_autosub( $p );
    }

    # implement repeat
    if ( $ref->{repeat} ) {
      foreach my $copy ( qw/ repeat separator / ) {
        $p->{$copy} = $ref->{$copy};
      }
    }

    # TODO: here is where menu placeholder generation would go.

    # replace the AST reference with the syntax reference

    delete $ref->{expr};
    $ref->{id} = $deref;

    $v->{macro}[$i] = bless $ref , 'Syntax::Ref';
  }
}

sub rewrite_tree {
  my ( $t , $v ) = @_;

  unless ( exists $v->{description} ) {
    $v->{description} = "any input";
  }

  if ( exists $v->{macro} ) {
    evaluate_macro_body( $v );
  }

  return 0;
}

sub rewrite {
  our @AST;

  if ( Settings::debug_switch( 's-struct' ) ) {
    print STDERR "dumping syntax tree before re-write\n";
    print STDERR ::Dumper( \@AST );
  }

  map {
    my $t = simple Traverse( $_ );

    $t->apply_breadth_first( \&rewrite_tree );
    Emit::queue( $_ );
  } @AST;

  if ( Settings::debug_switch( 's-struct' ) ) {
    print STDERR "dumping syntax tree after re-write\n";
    print STDERR ::Dumper( \@AST );
  }
}

#----------------------------------------------------------------------
# Generate else definition language
#----------------------------------------------------------------------
package Gen::else;

# First the formatting functions for easy access. These functions do
# the translation of generic text into valid syntax, converting or
# flagging it as illegal.

# currently it only converts a little.

sub cnv_to_ident {
  # else names must be upper-case ascii alphas, digits, or underscores.

  join ('_', map {
    $_ =~ s/-/_/g;         # translate all the illegal characters to underscores
    $_;
  }  @_  );
}

sub mk_decl_ident {
  my $ident = cnv_to_ident( @_ );
  uc( $ident );                # uppercase all the alpha characters.
}

sub mk_ref_ident {
  my $ident = cnv_to_ident( @_ );
  lc( $ident );                # lowercase all the alpha characters
}

sub quote {
  "\"" . shift() . "\"";
}

sub quote_context {
  my ( $context , $text ) = @_;

  my @wrap = ();

  if ( $context eq 'required' ) {
    @wrap = ( '{' , '}' );
  }
  elsif ( $context eq 'optional' ) {
    @wrap = ( '[' , ']' );
  }

  return join('',$wrap[0],$text,$wrap[1]);
}

# it should not be difficult to convert a placeholder to a token.

sub open {
  my ( $t , $type , $lang ) = @_;

  # tokens are symbols we will enter in the buffer, so keep them lowerspace.
  # placeholders are children of tokens, upper-case them to match the
  # classic ELSE style, and act as another barrier against collisions.

  # BROWN BAG: note the join for the token type is '-'. This should definitely
  # be user customizable for a more generic version.

  my $name = ( $type eq 'token' )
    ? join('-', $t->ns() )
    : mk_decl_ident( $t->ns() );

  # the opening stanza deletes a previous definition and then begins a new
  # declaration.

  my $kind = mk_decl_ident( $type );

  print STDOUT <<OPEN_DECL;
DELETE $kind $name -
  /LANGUAGE="$lang" -
DEFINE $kind $name -
  /LANGUAGE="$lang" -
OPEN_DECL

  undef;
}

sub close {
  print STDOUT "END DEFINE\n";
}

sub autosub {
  my $count = shift();

  if ( $count ) {
    print STDOUT <<SUBSPEC;
  /AUTO_SUBSTITUTE -
  /SUBSTITUTE_COUNT=$count -
SUBSPEC
  }
  else {
    print STDOUT <<SUBSPEC;
  /NOAUTO_SUBSTITUTE -
SUBSPEC
  }
}

our %repeat_abbrev = (
 h => 'HORIZONTAL',
 v => 'VERTICAL',
 a => 'CONTEXT_DEPENDENT',
  );

sub repeat {
  our %repeat_abbrev;
  my ( $sep , $repeat ) = @_;

  my $dup = $repeat_abbrev{ $repeat };

  print STDOUT <<DUPSPEC;
  /SEPARATOR="$sep" -
  /DUPLICATE="$dup" -
DUPSPEC
}

sub pref {
  my ( $t , $ref ) = @_;

  my $text =
    quote_context( $ref->{context},
                   mk_ref_ident( $t->ns(), $ref->{id} ) );

  if ( $ref->{repeat} ) {
    $text .= "...";
  }

  $text;
}

sub terminal {
  my $description = quote( shift() );

  print STDOUT <<TERMINAL;
  /TYPE=TERMINAL -
$description
TERMINAL
}

sub macro {
  my $t = shift();
  my $description = quote( shift() );

  my @lines = split /\n/ ,
    join( '' , map {
      my $text;
      if ( 'Syntax::Ref' eq ref ( $_ ) ) {
        $text = pref( $t, $_ );
      }
      else {
        $text = $_;
      }
      $text;
    } @_ );

  # get rid of both leading and trailing whitespace lines
  @lines = reverse Emit::trim_ws_lines( reverse Emit::trim_ws_lines( @lines ) );

  print STDOUT <<MACRO, join("\n", map { quote( $_ ) } @lines ) . "\n";
  /DESCRIPTION=$description -
  /TYPE=NONTERMINAL -
MACRO
}

#----------------------------------------------------------------------
# Emit
#----------------------------------------------------------------------
package Emit;

sub flush {
  # flush stdout
}

sub trim_ws {
  my $s = shift();

  $s =~ s/\s+$//;
  $s =~ s/^\s+//;

  $s;
}

sub trim_ws_lines {
  trim: my $tail = pop @_;
  goto trim if ( $tail =~ /^\s*$/ && @_ );

  push @_ , $tail;

  @_;
}

#----------------------------------------------------------------------
# major entry points.
#----------------------------------------------------------------------
our @queue = ();

sub reset {
  our @queue = ();
}

sub select_generator {
  my $gen = shift();

  # bind a generator.
  foreach my $func ( qw/
    open close
    autosub repeat
    macro terminal
  / ) {

    my ( $import , $from ) = ( join('_','gen',$func) ,
                               join('::', 'Gen' , $gen , $func ) );

#    print STDERR "importing $import from $from\n";
    *$import = \*{ $from };
  }
}

sub queue {
  our @queue;
  push our @queue, shift();
}

sub generate_vertex {
  my ( $t , $v ) = @_;

  gen_open( $t,
            ( exists $v->{decl} )
              ? $v->{decl}
              : 'placeholder',
            $Settings::emit_for_language );

  gen_autosub( ( exists $v->{autosub} ) ? $v->{autosub} : 0 );

  if ( exists $v->{repeat} ) {
    gen_repeat( $v->{separator} , $v->{repeat} );
  }

  my @description = trim_ws_lines( split /\n/, $v->{description} );
  @description = map { trim_ws( $_ ) } trim_ws_lines( reverse @description);

  if ( exists $v->{macro} ) {
    gen_macro( $t, join('',@description), @{ $v->{macro} } );
  }
  else {
    gen_terminal( join('',@description) );
  }

  gen_close();

  flush();

  undef;
}

sub generate {
  our @queue;

  if ( Settings::debug_switch( 'e-struct' ) ) {
    print STDERR "dumping syntax tree before emit\n";
    print STDERR ::Dumper( \@queue );
  }

  map {
    my $t = with_ns Traverse ( $_ );

    $t->apply_depth_first( \&generate_vertex );
  } @queue;
}

#----------------------------------------------------------------------
# main
#----------------------------------------------------------------------

package main;

sub reset_all_phases {
  Register::reset();
  Builder::reset();
  Syntax::reset();
  Emit::reset();
}

use XML::SAX::Machines qw/Pipeline/;

# A simple architecture for the assembler.

my $tr = Pipeline (
  # standard translation pipeline

  XMLFilter =>                  # Filter to eliminate pure XML document parts.

  PruneFilter =>                # Eliminate undesired languages etc. valid define material
                                # that is eliminated from the syntax.

  StripFilter =>                # a filter that removes the body data from elements that
                                # are purely containers.

  Parser =>                     # Parse definitions. Currently constructs a abstract
                                # structure

  \*STDERR                      # Any part of the document that is unhandled after translation
                                # is an error.
 );

PruneFilter::filter( LocalName => qr/span|prefix/ );  # filter unimplemented features.

Emit::select_generator('else');

input_file: foreach my $file ( @ARGV ) {

  if ($file eq "-" ) {
    $tr->parse_file( \*STDIN );
  }
  else {
    unless( -e $file ) {
      print STDERR "file $file not found - Ignoring argument.\n";
      next input_file;
    }

    $tr->parse_uri( $file );
  }

  # rewrite the AST generating the defitions
  Syntax::rewrite();

  # emit the definitions we have queued
  Emit::generate();

  reset_all_phases();
}

0;
