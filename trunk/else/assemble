#! /usr/bin/env perl
#----------------------------------------------------------------------
# Assemble
# Primary Author: Mike Mattie
# copyright: Mike Mattie (2007)
# License: GPLv3
#----------------------------------------------------------------------

unless ( @ARGV > 0 ) {
  print STDERR <<HOWTO;
assemble [language,...] [input-file]....

Assemble translates a XML input format to else-mode template
definitions.

The first arguement is the language to generate. the XML format
allows more than one language definition for a given template,
this arguement chooses which language will be emitted.

input-file... is a list of XML input files to process.
HOWTO
}

#----------------------------------------------------------------------
# debugging support
#----------------------------------------------------------------------

# currently the user can pass a list of debug switches as the first
# arguement seperated by ','
#
# example: -d s-struct,e-struct

use Data::Dumper;

#----------------------------------------------------------------------
# Settings
#----------------------------------------------------------------------
package Settings;

our %debug_flags = ();

if ( $ARGV[0] eq "-d" ) {
  # take each of the comma seperated debug flags and make a hash pair
  # out of them
  my @flags = split /,/, ( splice @ARGV,0,2 )[1];
  our %debug_flags = map { ( $_ => 1 ) } @flags;
}

sub debug_switch {
  # given a string that should be a debug switch ask if it was
  # enabled by the user.

  our %debug_flags;
  my $flag = shift();

  return ( $debug_flags{$flag} ) ? 1 : 0;
}

our $emit_for_language = shift( @ARGV );

#----------------------------------------------------------------------
# register
#----------------------------------------------------------------------

# The data builder that serializes SAX characters events into variables.

# I named it register because I needed a accumulator for SAX events,
# and having wrote intel assembler back in the day "ax" popped into
# my head.

# The primary purpose of Register is to answer the question: where does
# this go? for data delivered by characters SAX events.

# The main functions are: push,pop, recognize, and concat.

# push,pop allow you to recurse into new variables to stuff data.

# recognize is a necessary evil; you must pass element events
# to recognize so that the registers stack can be kept in sync
# with the document nesting. recognize should only be passed
# closing tags, or "end" SAX events.

#----------------------------------------------------------------------

package Register;
our @registers = ();              # the core stack data structure.

# Conceptually a simple stack for recursion. Each stack element is
# a pointer, and a match for end_element events to pop the stack.

# There are two element types that live in the registers stack. scopes
# and pointers.

# pointer     : [ element-name , data-key , data-ref ]
# scope       : [ recursion-level, data-ref ]

# The pointer combines a hash reference, a hash key, and a element
# name allowing character data to be delivered to an arbitrary
# hash.

# The scope is much different with a recursion-level, and a hash reference.
# It serves as the default root of a tree of pointers (children).

sub reset {
  # clear any global variables in this namespace.

  our @registers = ();
}

sub dump_stack {
  # print a dump of the @registers stack for debugging and diagnostics.

  our @registers;

  print STDERR "register [stack] = ",
    join(",",
         map {
           ( 'ARRAY' eq ref( $_ ) )
             ? join("->", $$_[0], $$_[1] )
             : "recursion = " . $_[0];
         } @registers ),
    "\n";
}

# distinguish between the two types of stack elements.

sub is_ptr {
  our @registers;
  my $i = shift();

  unless( defined($i) ) {
    $i = -1;
  }

  ( 'ARRAY' eq ref( $registers[$i] ) )
      ? 1
      : 0;
}

sub is_scope {
  our @registers;
  my $i = shift();

  unless( defined($i) ) {
    $i = -1;
  }

  ( 'Register::scope' eq ref( $registers[$i] ) )
      ? 1
      : 0;
}

sub default_ref {
  # return a default reference with element type ambiguity.
  our @registers;

  return ( is_ptr() )
    ? $registers[-1][2]
    : $registers[-1][1]
}

# push/pop scope elements.

# This is an opportunity to detect stack corruption which is actually
# the parser losing synchronization with the recursion of nested
# elements.

sub push_scope {
  my $ref = shift();
  push our @registers, bless [Builder::recursion_level(), $ref ], 'Register::scope' ;
}

sub pop_scope {
  our @registers;

  unless ( is_scope() ) {
    print STDERR "Register::pop_scope: top of stack is not a scope, stack is corrupted\n";
    dump_stack();

    die "Failed ! Register corruption discovered by pop_scope\n";
  }

  pop @registers;
}

sub replace_default {
  our @registers;

  my ( $element, $data_key ) = @_;

  # BROWN BAG:

  # element should be a SAX element. Instead it is a scalar that is
  # the name of the element.  At the time we call replace-default we
  # have the new element, not the element that started the default.

  # A much better solution: Store an ElementMatch instance along with
  # the recursion level. This issue should be addressed when
  # ElementMatch is weilded seriously to deal with NamespaceURI.

  # from the top of the register stack search down for a pointer that
  # matches the data-key.

  if ( Settings::debug_switch( 'register-replace' ) ) {
    print STDERR "replace before",::Dumper(\@registers), "\n";
  }

  my $i;
  for( $i = @registers - 1 ;
       $i >= 0 && is_ptr($i) ;
       $i-- ) {

    # when we find the data-key replace the element that we match on.
    if ( $registers[$i][1] eq $data_key ) {
      # replace the old default element with the new one

      $registers[$i][0] = $element;

      # since the default is probably right after the current marker we need to move
      # it to the top of the stack otherwise it will explode when the stack is popped.
      push @registers, splice @registers,$i,1;

      if ( Settings::debug_switch('register-replace') ) {
        print STDERR "replace after",::Dumper(\@registers), "\n";
      }

      return;
    }
  }

  # if we have failed we should be sitting at a current marker.
  unless ( $i > 0 ) {
    print STDERR "default for $data_key could not be found at recursion level: ", $registers[$i][0], "\n";
    die "Failed ! Register corruption discovered by replace_default\n";
  }
}

sub ready {
  # return true if a subsequent concat operation is valid. register stack must
  # be non-empty with a pointer type element on the top.

  our @registers;

  ( @registers > 0 && is_ptr() )
    ? 1 : 0;
}


sub push {
  # push a new pointer onto @registers. The element is given along
  # with the key to write to. data_ref is either specified as a third
  # arguement or when undef the reference of the previous pointer on
  # stack is aliased.

  my ( $element , $data_key , $data_ref ) = @_;

  print STDERR "WARNING ! probable parser noise interpreted as syntax\n"
    if ( $data_key =~  m/^\s*$/ );

  unless ( defined $data_ref ) {
    $data_ref = default_ref();
  }

  push our @registers , [ $element->{LocalName} , $data_key , $data_ref ];
}

sub pop {
  # pop a pointer.

  unless ( @registers > 0 ) {
    die "failed ! Register corruption discovered by pop\n";
  }

  unless ( is_ptr() ) {
    die "failed ! Register corruption discovered by pop - attempting to pop a current marker\n";
  }

  pop our @registers;
}

sub recognize {
  # we need a way to determine if a given element is relevant to the current
  # register. This way we can pop the register when the closing tag is
  # encountered.

  our @registers;

  my $element = shift();

  unless ( @registers > 0 && is_ptr() ) {
    return 0;
  }

  return ( ${ $registers[-1] }[0] eq $element->{LocalName} )
    ? 1
    : 0;
}

sub concat {
  # append to the hash/key indicated by the pointer on the top
  # of the register stack.

  our @registers;

  unless ( ready() && is_ptr() ) {
    die "failed ! Register corruption discovered by concat - top of stack is not a pointer\n";
  }

  my ( $data_key , $data_ref ) = ( $registers[-1][1],
                                   $registers[-1][2] );

  my $dribble = shift();

  if ( Settings::debug_switch('macro-literal') ) {
    print STDERR "register [concat] = $dribble\n";
  }

  if ( Settings::debug_switch('register') ) {
    print STDERR "register [pointer] = $data_key \@level ", Builder::recursion_level(), "\n";
    dump_stack();
  }

  if ( $data_ref->{$data_key} ) {
    $dribble = $data_ref->{$data_key} . $dribble;
  }

  $data_ref->{$data_key} = $dribble;
}

#----------------------------------------------------------------------
# Builder
#----------------------------------------------------------------------
package Builder;

# Construct the intermediate form usually referred to as 'define' or 'def'.

our @defines = ();

sub reset {
  our @defines = ();
}

sub recursion_level {
  our @defines;

  ( @defines > 0 )
    ? scalar @defines
    : 0;
}

sub new_define {
  our @defines;

  my $def = {
    # whenever we nest beyond root call it a placeholder.
    decl => ( @defines ) ? 'placeholder' : 'token',
#    lang => $current_language,
  };

  push @defines, $def;

  # set the default marker.

  my $element = shift();

  # the default marker has a reference to the define, this is important to make
  # sure that push will always work correctly without specifying a explicit
  # ref

  Register::push_scope( $def );
  Register::push( $element , 'description' );
}

#----------------------------------------------------------------------
# @defines must be non-empty, check with ready()
#----------------------------------------------------------------------
sub ready {
  return ( @defines > 0 ) ? 1 : 0;
}

sub define {
  our @defines;
  $defines[-1];
}

# define complete currently means discard as we are not building
# a tree yet.
sub define_complete {
  our @defines;

  # pop our 'current' marker on the register stack.
  Register::pop_scope();

  # pop off the define we have completed.
  my $finish = pop @defines;

  unless( defined( $finish ) ) {
    die "Absurd. define_complete called on non-existant define\n";
  }

  # the trailing literal data from the body of the macro may be lingering
  # in the data buffer.
  define_copy_macro( $finish );

  # if we have reached the root of the tree queue it for Syntax

  unless ( @defines > 0 ) {
    # TODO:

    # When it's time to prototype the error checking put it here so it can be
    # run after all the parsing is complete, and we haven't wrote anything bad
    # yet. We want to emit only the subset that is correct.

    if ( Settings::debug_switch( 'b-struct' ) ) {
      print STDERR ::Dumper( $finish ) , "\n";
    }

    # queue for rewrite
    Syntax::queue( $finish );
  }
}

sub get_placeholder_for {
  # ghetto. Make a bunch of nested hashes if necessary.

  my ( $p , $def , $ref ) = @_;

  unless( defined( $def ) ) {
    die "Absurd trying to get a non-terminal for a null define\n";
  }

  unless ( exists $def->{ptable} ) {
    $def->{ptable} = {};
  }

  my $ptable = $def->{ptable};

  # already exists case
  if ( exists $ptable->{$p} ) {
    return $ptable->{$p};
  }

  # create new case
  unless ( defined($ref) ) {
    $ref = {};
  }

  $ptable->{$p} = $ref;

  $ref;
}

sub get_placeholder {
  our @defines;

  # we will always get a name minimally.
  my $p = shift();

  # if we still have arguments we are attaching a existing define of some sort.
  my ( $recursion_level, $ref ) = @_;

  if ( $recursion_level ) {
    unless ( $defines[$recusion_level] ) {
      die "invalid token requested by recursion_level: $recursion_level in get_placeholder\n";
    }
  }
  else {
    $recursion_level = -1;
  }

  my $def = $defines[$recursion_level];

  get_placeholder_for( $p , $def , $ref );
}

sub define_append_macro {
  my ( $def , $data ) = @_;
  if ( exists $def->{macro} ) {
    push @{ $def->{macro} } , $data;
  }
  else {
    $def->{macro} = [ $data ];
  }
}

sub define_copy_macro {
  # copy from the data "buffer" to the actual macro structure.
  # hopefully the caller waited until all the characters
  # events were sent.

  # clears ->data

  my $def = shift();

  unless( $def->{data} ) {
    return;
  }

  define_append_macro( $def , $def->{data} );
  $def->{data} = '';
}

sub define_insert {
  # flush any literal sequence in the buffer
  my $def = define();
  define_copy_macro( $def );

  define_append_macro( $def , shift() );
}

#----------------------------------------------------------------------
# Builder::Ref
#----------------------------------------------------------------------
package Builder::Ref;

# references to placeholders contain much of the placeholder spec. This
# object is a specification of how that placeholder is evaluated.

sub new {
  shift();

  # the Builder::Ref constructor is a key point in the design of the
  # assembler.

  # Background:

  # The user constructs a specification of how they want the placeholder
  # to behave and give it a name. Under the else-mode definition language
  # this is specification is spread out in both a place-holder tree written
  # by the user, and the reference to the root of that placeholder tree
  # in a template body.

  # This makes sense where the definition language is so close
  # to the data structure builder.

  # The purpose of assemble is to enhance by generating as much of the
  # definition as possible. The trees of placeholders, wherever
  # possible are no longer written by the user but generated by the
  # assembler.  Things like menus should be generated from a minimal
  # spec given by the user, not coded by the user.

  # To cleanly seperate the gathering of spec (parsing) from
  # generation (AST rewrite) An abstraction barrier is implemented here.

  # The specification is gathered up in a list of pairs. The keys must
  # be defined by Syntax::evaluate_macro_body to be meaningful.

  # The context is whatever part of the placeholder specification is
  # orthogonal to the definition of a placeholder.

  # Currently this is wether it is optional or not (killable in
  # emacs-else parlance)

  # this used to be a real constructor , but now it's been gutted.
  bless {
    @_
  }, 'Builder::Ref';
}

#----------------------------------------------------------------------
# DefineFilter
#
# Along with misc XML document parts drop anything that is documentation
# that doesn't end up in the macro definition itself.
#----------------------------------------------------------------------
package XMLFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

sub comment {
  undef;
}

sub xml_decl {
  undef;
}

sub processing_instruction {
  undef;
}

#----------------------------------------------------------------------
# ElementMatch
#----------------------------------------------------------------------
package ElementMatch;

sub new_filter {
  shift();
  bless { @_ } , 'ElementMatch';
}

sub new_drop {
  shift();

  my $spec = shift();
  # initialize the count
  my %copy = ( %$spec , count => 1 );

  bless \%copy , 'ElementMatch';
}

sub matches {
  my ( $self , $element ) = @_;

  # ignore data keys, use all the search keys.
  foreach my $must_match ( grep { !/count/ } keys %$self ) {
    unless ( $element->{$must_match}
             && $element->{$must_match} =~ /$self->{$must_match}/ ) {
      return 0;
    }
  }

  return 1;
}

sub consume_start {
  my ( $self , $element ) = @_;

  if ( $self->matches( $element ) ) {
    my $self->{count}++;
  }

  # ignore data keys, use all the search keys.
  foreach my $check ( grep { !/count/ } keys %$self ) {
    unless ( $element->{$check}
             && $element->{$check} =~ /$self->{$check}/ ) {
      return;
    }
  }
}

sub consume_end {
  # when this returns true the match object has expired.

  my ( $self , $element )  = @_;

  if( $self->matches( $element ) ) {
    --$self->{count}
  }

 # invert bool , it's not final until it's nil.
 ( $self->{count} ) ? 0 : 1;
}

#----------------------------------------------------------------------
# PruneFilter
#----------------------------------------------------------------------
package PruneFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

# implement a simple matching object for elements

our @blacklist = ();
our $drop = undef;

sub filter {
  our @blacklist;

  my $filter = new_filter ElementMatch( @_ );
  push @blacklist, $filter;

  $filter;
}

sub prune {
  our $drop = new_drop ElementMatch( filter( @_ ) );
}

sub start_element {
  our $drop;
  my ( $self , $element ) = @_;

  if ( $drop ) {
    $drop->consume_start( $element );
    return;
  }

  foreach my $filter ( @blacklist ) {
    if ( $filter->matches( $element ) ) {
      $drop = new_drop ElementMatch( $filter );
      goto zap;
    }
  }

  $self->{Handler}->start_element($element);

 zap: undef;
}

sub end_element {
  our $drop;

  my ( $self , $element ) = @_;

  if ( $drop ) {
    if ( $drop->consume_end( $element ) ) {
      $drop = undef;
    }

    return;
  }

  $self->{Handler}->end_element($element);
}

sub characters {
  our $drop;
  my ( $self , $data ) = @_;

  if ( $drop ) {
    return;
  }

  $self->{Handler}->characters( $data );
}

#----------------------------------------------------------------------
# StripFilter
#
# strip the body from processing for a given element.
#----------------------------------------------------------------------
package StripFilter;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

our @strip_list = ( qw/ else token / );

our @strip_flag = ();
our $level = 0;

sub strip_data {
  our $level, @strip_flag;

  ( @strip_flag && $strip_flag[-1] == $level )
    ? 1
    : 0;
}

sub strip_parent {
  our $level, $strip_flag;
  push @strip_flag, $level - 1;
}

sub start_element {
  our $level++ , @strip_flag;

  my ( $self , $element ) = @_;

  if ( scalar grep { element->{LocalName} eq $_ } @strip_list ) {
    push @strip_flag , $level;
  }

  $self->{Handler}->start_element($element);
}

sub end_element {
  our $level--, @strip_flag;

  while( @strip_flag && $level < @strip_flag[-1] ) {
    pop @strip_flag;
  }

  my ( $self , $element ) = @_;

  $self->{Handler}->end_element($element);
}

sub characters {
  my ( $self , $data ) = @_;

  return if ( strip_data() );
  $self->{Handler}->characters( $data );
}

#----------------------------------------------------------------------
# Parser
#
# Implement the Parser as SAX event handlers that drive AST generation.
#----------------------------------------------------------------------
package Parser;

use XML::SAX::Base;
@ISA = ('XML::SAX::Base');

# elements defined by the Assembler implementation.
our %defined = (
  token => [ qw/Builder::new_define define_end/ ],
  name => [ qw/name_start name_end/ ],
  description => [ 'description_start' , undef ],

  body => [ 'macro_start', undef ],
  prefix => [ 'prefix_start' , undef ],
  r => [ 'required_start' , undef ],
 );

#----------------------------------------------------------------------
# dispatch_reserved
#
# look up an element in a table of handlers. Execute the handler if
# a match is found. Unlike the SAX event handlers these are keyed by
# XML elements.
#----------------------------------------------------------------------

sub dispatch_reserved {
  our %defined;

  my ( $index , $element ) = @_;
  my $name = $element->{LocalName};

  if ( exists $defined{$name} ) {
    my $href = ${ $defined{ $name } }[$index];

    # execute the event handler if there is one.
    &{ $href }( $element ) if ( defined $href );
    return 1;
  }

  return 0;
}

sub dispatch_reserved_start { dispatch_reserved( 0 , @_ ); }
sub dispatch_reserved_end { dispatch_reserved( 1 , @_ ); }

#----------------------------------------------------------------------
# SAX event handlers that drive dispatch_element
#----------------------------------------------------------------------

sub start_element {
  my ( $self , $element ) = @_;

  #print STDERR "Dump element ", ::Dumper( $element ), "\n";

  if ( $element->{NamespaceURI} ) {
    unless ( $element->{NamespaceURI} eq $Settings::emit_for_language ) {
      print STDERR "Notice: Language ", $element->{NamespaceURI}, " is not on the guest list.\n";
      PruneFilter::prune( NamespaceURI => $element->{NamespaceURI} );

      return;
    }
  }

  return if ( dispatch_reserved_start( $element ) );

  # elements not recognized are declaration of placeholders
  # inside of tokens.

  if ( Builder::ready() ) {
    Register::push( $element , 'description' ,
                    Builder::get_placeholder( $element->{LocalName} ) );
  }
}

sub end_element {
  my ( $self , $element ) = @_;

  # The data accumulator needs a signal to stop recording.
  if ( Register::recognize( $element ) ) {
    Register::pop();
  }

  return if dispatch_reserved_end( $element );
}

sub characters {
  my ( $self ,  $data ) = @_;

  if ( Register::ready() ) {
    Register::concat( $data->{Data} );
  }
  else {
    $self->{Handler}->characters( $data );
  }
}

#----------------------------------------------------------------------
# high level event handlers driven by dispatch_element
#----------------------------------------------------------------------

sub define_end {
  # make sure the register gets cleaned up before we finalize with
  # Builder::define_complete.

  my $element = shift();
  if ( Register::recognize( $element ) ) {
    Register::pop();
  }

  Builder::define_complete();
}

sub macro_start {
  my $element = shift();

  # macros begin by recording into ->data. this is basically
  # a input buffer for the literal parts of the macro body.

  Register::push( $element , 'data' );
}

sub name_start {
  my $element = shift();
  Register::push( $element , 'name' );
}

sub name_end {
  # we cannot attatch a nested define to the parent define until we have the name.
  # so we need to capture the event of </name>, and attatch the child to the parent.

  if( Builder::recursion_level() > 1 ) {
    my $def = Builder::define();
    Builder::get_placeholder( $def->{name} , -2 , $def);
  }
}

# description means we want verbose documentation in the document, but we are
# going to create a terse summary for the token definition. Copy this body
# as the summary and strip the body of the parent.
sub description_start {
  my $element = shift();

  StripFilter::strip_parent();
  Register::replace_default( 'description', 'description' );
}

sub extract_repeat_controls {
  my $element = shift();

  foreach my $spec ( qw/ h v a / ) {
    if ( $element->{Attributes}->{'{}' . $spec}->{Value} ) {

      # set separator and duplicate for repeated placeholders.

      return (
        separator => $element->{Attributes}->{'{}' . $spec}->{Value},
        repeat => $spec,
       )
    }
  }

  return ();
}

sub required_start {
  my $element = shift();

  # need to extract the p attribute. This is our expression.
  my $expr = $element->{Attributes}->{'{}p'}->{Value};

  # Builder::Ref collects the specification for how the placeholder is
  # expanded. This spec is inserted into the ->macro sequence for
  # deferred evaluation during the syntax phase.

  # At this point the specification of the placeholder needs to be complete
  # aside from affects like auto-substitute which are computed by collision.

  my $term = Builder::define_insert( new Builder::Ref( context => 'required',
                                                       expr => $expr,
                                                       extract_repeat_controls( $element ),
                                                      ));
}

sub prefix_start {
  my $element = shift();
  Register::push( $element, 'prefix' , undef );
}

#----------------------------------------------------------------------
# Syntax
#----------------------------------------------------------------------
package Syntax;

our @AST = ();

# a namespace stack allows me to avoid doing child -> parent linking
# in the AST tree.

# I am keeping the namespace generation in Syntax in the hope that I
# can someday compact the namespace identifiers without making them
# too ugly.

our @namespace = ();

sub reset {
  our @AST = ();
  our @namespace = ();
}

sub queue {
  # add a tree to the AST list.
  push our @AST , shift();
}

sub reject_tree {
  my ( $reason , $tree ) = shift();
  print STDERR "rejecting AST tree: $reason\n";
  print STDERR ::Dumper($tree);
}

#----------------------------------------------------------------------
# meat
#----------------------------------------------------------------------

# alias the get_placeholder implementation in Builder:: that is
# not specialized for the parse phase.

*get_placeholder = \*Builder::get_placeholder_for;

sub is_node {
  my $v = shift();
  return ( exists $v->{name} ) ? 1 : 0;
}

sub increment_autosub {
  # if the syntax analysis was a real phase it would be possible
  # to prune the defines with autosub=1 . However this is the
  # default count value.

  my $define = shift();

  if ( exists $define->{autosub} ) {
    $define->{autosub}++;
  }
  else {
    $define->{autosub} = 1;
  }
}

sub evaluate_macro_body {
  our @namespace;

  # This is a critical design point: where all of the AST rewrites begin.

  # All placeholders are generated as unique. The advantage is that
  # the user can choose unique names when there is a distinction to be
  # made, and not bother with policing unique-ness when it has no
  # impact on function.

  # However there can be multiple references to the same placeholder that
  # is functionally essential, as in the case of the auto-substitute
  # function.

  # To resolve this question evaluation will generate a placeholder
  # unless a existing definition is found. If that definition is
  # functionally compatible the reference will merge: e.g update
  # auto-substitute reference count.

  # If the generated and existing placeholder's are exclusive then
  # the generated placeholder will be named uniquely and returned.

  # This behavior is the concise and flexible without sacrificing
  # correctness , which is do everything the original else-mode
  # definitions could do.

  my $tree = shift();

  my $i ; for ( $i = 0 ; $i < @{ $tree->{macro} } ; $i++ ) {
    my $ref = $tree->{macro}[$i];

    # skip over the literal spans in the macro
    next unless ( 'Builder::Ref' eq ref( $ref ) );

    # need to split any modififer
    my ( $modifier , $deref ) = $ref->{expr} =~ m/([@])?(.*)/;
    # print STDERR "expr: $expr modifier = $modifier  , deref = $deref\n";

    my $p = get_placeholder( $deref , $tree );

    # implement autosub computation
    if ( defined( $modifier ) && $modifier eq '@' ) {
      increment_autosub( $p );
    }

    # implement repeat
    if ( $ref->{repeat} ) {
      foreach my $copy ( qw/ repeat separator / ) {
        $p->{$copy} = $ref->{$copy};
      }
    }

    # TODO: here is where menu placeholder generation would go.

    # replace the AST reference with the syntax reference

    delete $ref->{expr};
    $ref->{namespace} = [ @namespace , $deref ];

    $tree->{macro}[$i] = bless $ref , 'Syntax::Ref';
  }
}

sub rewrite_tree {
  our @namespace;
  my $tree = shift();

  # even placeholders that aren't really templates with bodies should
  # have a ->{name} field. Otherwise we are screwed.

  unless ( exists $tree->{name} ) {
    reject_tree( 'token does not have a name' , $tree );
    return 0;
  }

  # add another level to the namespace, record in the tree
  push @namespace , $tree->{name};
  $tree->{namespace} = [ @namespace ];

  # we don't need to distinguish between nodes and leaves anymore
  # for this vertex.
  delete $tree->{name};

  # no longer need the data buffer. purely a SAX parsing mechanism.
  if ( exists $tree->{data} ) {
    delete $tree->{data};
  }

  # make sure we always have a decl. default to placeholder unless specified.
  unless ( exists $tree->{decl} ) {
    $tree->{decl} = 'placeholder';
  }

  unless ( exists $tree->{description} ) {
    $tree->{description} = "any input";
  }

  my $ptable = $tree->{ptable};

  foreach my $v ( keys %{$ptable} ) {
    if ( $v =~ m/^\s*$/ ) {
      # getting some weird garbage from keys , filter the crap until I can find the
      # bug, probably have an odd number of elements in the hash or some such crap.

      print STDERR "warning ! deleting \"$v\" garbage key in ptable\n";
      delete $ptable->{$_};
      next;
    }

    if ( is_node( $ptable->{$v} ) ) {
      unless ( rewrite_tree( $ptable->{$v} ) ) {
        delete $ptable->{$v};
      }
    }
    else {
      # add in the fields that are always missing on the leafs,
      # this keeps the emitter simple.
      $ptable->{$v}->{decl} = 'placeholder';
      $ptable->{$v}->{namespace} = [ @namespace , $v ];
    }
  }

  if ( exists $tree->{macro} ) {
    evaluate_macro_body( $tree );
  }

  # discard the current namespace level
  pop @namespace;

  return 1;
}

sub rewrite {
  our @AST, $language;

  if ( Settings::debug_switch( 's-struct' ) ) {
    print STDERR "dumping syntax tree before re-write\n";
    print STDERR ::Dumper( \@AST );
  }

  map {
    if ( rewrite_tree( $_ ) ) {
      Emit::queue( $_ );
    }
  } @AST;

  if ( Settings::debug_switch( 's-struct' ) ) {
    print STDERR "dumping syntax tree after re-write\n";
    print STDERR ::Dumper( \@AST );
  }
}

#----------------------------------------------------------------------
# Generate else definition language
#----------------------------------------------------------------------
package Gen::else;

# First the formatting functions for easy access. These functions do
# the translation of generic text into valid syntax, converting or
# flagging it as illegal.

# currently it only converts a little.

sub cnv_to_ident {
  # else names must be upper-case ascii alphas, digits, or underscores.

  join ('_', map {
    $_ =~ s/-/_/g;         # translate all the illegal characters to underscores
    $_;
  }  @_  );
}

sub mk_decl_ident {
  my $ident = cnv_to_ident( @_ );
  uc( $ident );                # uppercase all the alpha characters.
}

sub mk_ref_ident {
  my $ident = cnv_to_ident( @_ );
  lc( $ident );                # lowercase all the alpha characters
}

sub quote {
  "\"" . shift() . "\"";
}

sub quote_context {
  my ( $context , $text ) = @_;

  my @wrap = ();

  if ( $context eq 'required' ) {
    @wrap = ( '{' , '}' );
  }

  return join('',$wrap[0],$text,$wrap[1]);
}

# it should not be difficult to convert a placeholder to a token.

sub open {
  my ( $namespace , $type , $lang ) = @_;

  # tokens are symbols we will enter in the buffer, so keep them lowerspace.
  # placeholders are children of tokens, upper-case them to match the
  # classic ELSE style, and act as another barrier against collisions.

  # BROWN BAG: note the join for the token type is '-'. This should definitely
  # be user customizable for a more generic version.

  my $name = ( $type eq 'token' )
    ? join('-', @$namespace )
    : mk_decl_ident( @$namespace );

  # the opening stanza deletes a previous definition and then begins a new
  # declaration.

  my $kind = mk_decl_ident( $type );

  Emit::push_emit( <<OPEN_DECL );
DELETE $kind $name -
  /LANGUAGE="$lang" -
DEFINE $kind $name -
  /LANGUAGE="$lang" -
OPEN_DECL

  undef;
}

sub close {
  Emit::pop_emit( "END DEFINE\n" );
}

sub autosub {
  my $count = shift();

  if ( $count ) {
    Emit::printer( <<SUBSPEC );
  /AUTO_SUBSTITUTE -
  /SUBSTITUTE_COUNT=$count -
SUBSPEC
  }
  else {
    Emit::printer( <<SUBSPEC );
  /NOAUTO_SUBSTITUTE -
SUBSPEC
  }
}

our %repeat_abbrev = (
 h => 'HORIZONTAL',
 v => 'VERTICAL',
 a => 'CONTEXT_DEPENDENT',
  );

sub repeat {
  our %repeat_abbrev;
  my ( $sep , $repeat ) = @_;

  my $dup = $repeat_abbrev{ $repeat };

  Emit::printer( <<DUPSPEC );
  /SEPARATOR="$sep" -
  /DUPLICATE="$dup" -
DUPSPEC
}

sub pref {
  my $ref = shift();

  my $text =
    quote_context( $ref->{context},
                   mk_ref_ident( @{ $ref->{namespace} } ) );

  if ( $ref->{repeat} ) {
    $text .= "...";
  }

  $text;
}

sub terminal {
  my $description = quote( shift() );

  Emit::printer( <<TERMINAL );
  /TYPE=TERMINAL -
$description
TERMINAL
}

sub macro {
  my $description = quote( shift() );

  my @lines = split /\n/ ,
    join( '' , map {
      my $text;
      if ( 'Syntax::Ref' eq ref ( $_ ) ) {
        $text = pref( $_ );
      }
      else {
        $text = $_;
      }
      $text;
    } @_ );

  # get rid of both leading and trailing whitespace lines
  @lines = reverse Emit::trim_ws_lines( reverse Emit::trim_ws_lines( @lines ) );

  Emit::printer(<<MACRO, join("\n", map { quote( $_ ) } @lines ) . "\n" );
  /DESCRIPTION=$description -
  /TYPE=NONTERMINAL -
MACRO
}

#----------------------------------------------------------------------
# Emit
#----------------------------------------------------------------------
package Emit;

#----------------------------------------------------------------------
# emit stack.
#----------------------------------------------------------------------

# The recursion involved in emitting the trees means that writing
# output directly to a stream during processing won't work.
# serialize at complete definitions with a stack.

our @emit_stack = ();

sub push_emit {
  push our @emit_stack, join('', @_ );
}

sub printer {
  our @emit_stack;
  $emit_stack[-1] .= join('', @_ );
}

sub pop_emit {
  our @emit_stack;
  print STDOUT join('', pop @emit_stack , @_ );
}

sub flush {
  our @emit_stack;
  pop_emit() if ( @emit_stack > 0 );
}

sub trim_ws {
  my $s = shift();

  $s =~ s/\s+$//;
  $s =~ s/^\s+//;

  $s;
}

sub trim_ws_lines {
  trim: my $tail = pop @_;
  goto trim if ( $tail =~ /^\s*$/ && @_ );

  push @_ , $tail;

  @_;
}

#----------------------------------------------------------------------
# major entry points.
#----------------------------------------------------------------------
our @queue = ();

sub reset {
  our @emit_stack = ();
  our @queue = ();
}

sub select_generator {
  my $gen = shift();

  # bind a generator.
  foreach my $func ( qw/
    open close
    autosub repeat
    macro terminal
  / ) {

    my ( $import , $from ) = ( join('_','gen',$func) ,
                               join('::', 'Gen' , $gen , $func ) );

#    print STDERR "importing $import from $from\n";
    *$import = \*{ $from };
  }
}

sub queue {
  our @queue;
  push our @queue, shift();
}

sub generate_tree {
  my $tree = shift();

  gen_open( $tree->{namespace}, $tree->{decl}, $Settings::emit_for_language );

  # Ideally what is in the ptable is all terminal type definitions.
  # anything that is non-terminal should be outside of ptable.

  map { generate_tree( $_ ) } ( values %{ $tree->{ptable} } );

  gen_autosub( ( exists $tree->{autosub} ) ? $tree->{autosub} : 0 );

  if ( exists $tree->{repeat} ) {
    gen_repeat( $tree->{separator} , $tree->{repeat} );
  }

  my @description = trim_ws_lines( split /\n/, $tree->{description} );
  @description = map { trim_ws( $_ ) } trim_ws_lines( reverse @description);

  if ( exists $tree->{macro} ) {
    gen_macro( join('',@description), @{ $tree->{macro} } );
  }
  else {
    gen_terminal( join('',@description) );
  }

  gen_close();
}

sub generate {
  map { generate_tree( $_ ) } our @queue;
  flush();
}

#----------------------------------------------------------------------
# main
#----------------------------------------------------------------------

package main;

sub reset_all_phases {
  Register::reset();
  Builder::reset();
  Syntax::reset();
  Emit::reset();
}

use XML::SAX::Machines qw/Pipeline/;

# A simple architecture for the assembler.

my $tr = Pipeline (
  # standard translation pipeline

  XMLFilter =>                  # Filter to eliminate pure XML document parts.

  PruneFilter =>                # Eliminate undesired languages etc. valid define material
                                # that is eliminated from the syntax.

  StripFilter =>                # a filter that removes the body data from elements that
                                # are purely containers.

  Parser =>                     # Parse definitions. Currently constructs a abstract
                                # structure

  \*STDERR                      # Any part of the document that is unhandled after translation
                                # is an error.
 );

PruneFilter::filter( LocalName => qr/span|prefix/ );  # filter unimplemented features.

Emit::select_generator('else');

input_file: foreach my $file ( @ARGV ) {
  unless( -f $file ) {
    print STDERR "file $file not found - Ignoring argument.\n";
    next input_file;
  }

  reset_all_phases();

  # parse the input
  $tr->parse_uri( $file );

  # rewrite the AST generating the defitions
  Syntax::rewrite();

  # emit the definitions we have queued
  Emit::generate();
}
